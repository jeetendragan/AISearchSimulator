{"version":3,"sources":["webpack:///./$_lazy_route_resource lazy namespace object","webpack:///./src/app/app.component.html","webpack:///./src/app/simulator/help-dialog.html","webpack:///./src/app/simulator/simulator.component.html","webpack:///./src/Utils/BestFitSolver.ts","webpack:///./src/Utils/BinaryHeapStrategy.ts","webpack:///./src/Utils/BipartiteChecker.ts","webpack:///./src/Utils/BreadthFirstSolver.ts","webpack:///./src/Utils/ConvexHull.ts","webpack:///./src/Utils/DepthFirstSolver.ts","webpack:///./src/Utils/GeneralAlgorithms.ts","webpack:///./src/Utils/GraphBridges.ts","webpack:///./src/Utils/IdGenerator.ts","webpack:///./src/Utils/NodeStateInSearch.ts","webpack:///./src/Utils/NodeStateInSearchColorMapper.ts","webpack:///./src/Utils/PriorityQueue.ts","webpack:///./src/Utils/Queue.ts","webpack:///./src/Utils/SearchSolvers.ts","webpack:///./src/Utils/Solution.ts","webpack:///./src/Utils/TopologicalSorting.ts","webpack:///./src/Utils/UIElementEdge.ts","webpack:///./src/Utils/UIElementNode.ts","webpack:///./src/Utils/UniformCostSolver.ts","webpack:///./src/Utils/Utility.ts","webpack:///./src/Utils/XY.ts","webpack:///./src/app/app-routing.module.ts","webpack:///./src/app/app.component.css","webpack:///./src/app/app.component.ts","webpack:///./src/app/app.module.ts","webpack:///./src/app/material/material.module.ts","webpack:///./src/app/simulator/simulator.component.css","webpack:///./src/app/simulator/simulator.component.ts","webpack:///./src/environments/environment.ts","webpack:///./src/main.ts","webpack:///jsdom (ignored)","webpack:///jsdom/lib/jsdom/living/generated/utils (ignored)","webpack:///jsdom/lib/jsdom/utils (ignored)"],"names":[],"mappings":"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","file":"main-es2015.js","sourcesContent":["function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(function() {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = function() { return []; };\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nmodule.exports = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = \"./$$_lazy_route_resource lazy recursive\";","module.exports = \"<router-outlet></router-outlet>\\n\"","module.exports = \"<h1 mat-dialog-title>Help Dialog</h1>\\n<div mat-dialog-content>\\n    <hr>\\n    <span>&#10003;</span> Create nodes by double clicking or by clicking the <mat-icon>scatter_plot</mat-icon> button.<br>\\n    <span>&#10003;</span> Create edge by selecting the <mat-icon>call_made</mat-icon> button, and then selecting the nodes.\\n    To unselect the start node, press ESC or click in empty space.<br>\\n    <span>&#10003;</span> Define a start node and a goal node by selecting a node and choosing the option on the right.<br>\\n    <span>&#10003;</span> Select an algorithm and start the simulator.<br>\\n    <span>&#10003;</span> Zoom in by clicking on the <mat-icon>zoom_in</mat-icon> button or scroll down.<br>\\n    <span>&#10003;</span> Zoom out by clicking on the <mat-icon>zoom_out</mat-icon> button or scroll up.<br>\\n    <span>&#10003;</span> Go into the pan state by clicking <mat-icon>pan_tool</mat-icon> button and then drag the canvas OR Drag the canvas by pressing ALT key.<br>\\n    <br>\\n    <hr>\\n\\n    Note\\n    <ul>\\n        <li>Nodes with a white border are unvisited.</li>\\n        <li>Nodes with a black border are currently in the fringe.</li>\\n        <li>Nodes with a yellow border have been visited.</li>\\n    </ul>\\n    \\n</div>\\n\"","module.exports = \"<div fxLayout=\\\"row\\\" class=\\\"contentMain\\\" id=\\\"contentMain\\\">\\n    <div class=\\\"canvasWrapper\\\" id=\\\"canvasWrapper\\\">\\n        <canvas class=\\\"canvasElement\\\" id=\\\"canvasElement\\\"></canvas>\\n        <div class=\\\"floatingMainMenu\\\" fxLayout=\\\"column\\\" *ngIf=\\\"activeObject == null\\\">\\n            <div fxLayout=\\\"row\\\">\\n                <button mat-icon-button class=\\\"optionsButton\\\" matTooltip=\\\"Add node\\\" matTooltipPosition=\\\"below\\\" (click)=\\\"AddNode()\\\">\\n                    <mat-icon>fiber_manual_record</mat-icon>\\n                </button>\\n                <button mat-icon-button class=\\\"optionsButton\\\" matTooltip=\\\"Add nodes randomly\\\" matTooltipPosition=\\\"below\\\" (click)=\\\"AddRandomNodes()\\\">\\n                    <mat-icon>scatter_plot</mat-icon>\\n                </button>\\n                <button mat-icon-button (click)=\\\"toggleEdgeState()\\\" class=\\\"optionsButton\\\" matTooltip=\\\"Add Directed Edge\\\" matTooltipPosition=\\\"below\\\"\\n                    [style.color]=\\\"isLinkingEnabled ? '#FFFFFF':'#000000'\\\" [style.backgroundColor]=\\\"isLinkingEnabled ? '#008000':'#FFFFFF'\\\">\\n                    <mat-icon>call_made</mat-icon>\\n                </button>\\n                <button mat-icon-button (click)=\\\"toggleUndirectedEdgeState()\\\" class=\\\"optionsButton\\\" matTooltip=\\\"Add Undirected Edge\\\" matTooltipPosition=\\\"below\\\"\\n                    [style.color]=\\\"isLinkingBidirectional ? '#FFFFFF':'#000000'\\\" [style.backgroundColor]=\\\"isLinkingBidirectional ? '#008000':'#FFFFFF'\\\">\\n                    <mat-icon>sync_alt</mat-icon>\\n                </button>\\n                <button mat-icon-button class=\\\"optionsButton\\\" matTooltip=\\\"How to use the simulator?\\\" matTooltipPosition=\\\"below\\\"\\n                    (click)=\\\"showHelp()\\\">\\n                    <mat-icon>help</mat-icon>\\n                </button>\\n            </div>\\n            <div>\\n                <mat-form-field>\\n                    <mat-label>Algorithm</mat-label>\\n                    <mat-select [(ngModel)]=\\\"selectedAlgorithm\\\" name=\\\"food\\\">\\n                        <mat-option *ngFor=\\\"let algorithm of algorithms\\\" [value]=\\\"algorithm\\\">\\n                            {{algorithm}}\\n                        </mat-option>\\n                    </mat-select>\\n                </mat-form-field>\\n            </div>\\n            <div>\\n                <button mat-raised-button (click)=\\\"runSimulator()\\\">\\n                    Run algorithm\\n                    <mat-icon>play_arrow</mat-icon>\\n                </button>\\n            </div>\\n            <div>\\n                <div *ngFor=\\\"let n of numbers\\\">{{n}},</div>\\n            </div>\\n            <div style=\\\"margin-top: 35px; border-top: 1px solid grey; padding-top: 10px; color: rgb(163, 16, 16); \\\">\\n                Made by <a href=\\\"http://www.the-algoschool.com\\\" target=\\\"_blank\\\" style=\\\"color:#000; text-decoration: underline;\\\">The AlgoSchool</a><br>\\n                Like the project? Contribute on <a href=\\\"https://github.com/jeetendragan/AISearchSimulator\\\" target=\\\"_blank\\\" style=\\\"color:#000; text-decoration:underline;\\\">GitHub.</a>\\n            </div>\\n        </div>\\n        <div class=\\\"floatingMainMenu\\\" fxLayout=\\\"column\\\" *ngIf=\\\"activeObject != null && activeObject.type=='UIElementNode'\\\">\\n            <div style=\\\"margin-bottom: 5px;\\\">Node type: {{getNodeTypeAsString(activeObject)}} </div>\\n            <div style=\\\"margin-bottom: 5px;\\\">\\n                <button\\n                    mat-raised-button \\n                    style=\\\"background-color: #0849A2; color: white;\\\"\\n                    (click)=\\\"makeStartNode(activeObject)\\\">\\n                    Make start state\\n                </button>\\n            </div>\\n            <div style=\\\"margin-bottom: 5px;\\\">\\n                <button \\n                    (click)=\\\"makeGoalNode(activeObject)\\\"\\n                    mat-raised-button style=\\\"background-color: #08A229; color: white;\\\">\\n                    Make goal state\\n                </button>\\n            </div>\\n            <div style=\\\"margin-bottom: 5px;\\\">\\n                <button\\n                    mat-raised-button class=\\\"optionsButton\\\"\\n                    (click)=\\\"makeIntermediateNode(activeObject)\\\"\\n                    style=\\\"background-color: #FF5733; color: white\\\">\\n                    Make intermediate state\\n                </button>\\n            </div>\\n        </div>\\n        <div class=\\\"floatingMainMenu\\\" *ngIf=\\\"activeObject != null && activeObject.type=='UIElementEdge'\\\">\\n            This is an edge\\n        </div>\\n        <div class=\\\"uiUtilityMenu\\\" fxLayout=\\\"column\\\">\\n            <div>\\n                <button mat-icon-button class=\\\"optionsButton\\\" matTooltip=\\\"Clear all\\\" matTooltipPosition=\\\"below\\\"\\n                    (click)=\\\"clearAll()\\\">\\n                    <mat-icon>replay</mat-icon>\\n                </button>\\n            </div>\\n            <div>\\n                <button mat-icon-button class=\\\"optionsButton\\\" matTooltip=\\\"Zoom in\\\" matTooltipPosition=\\\"below\\\"\\n                    (click)=\\\"zoomIn()\\\">\\n                    <mat-icon>zoom_in</mat-icon>\\n                </button>\\n            </div>\\n            <div>\\n                <button mat-icon-button class=\\\"optionsButton\\\" matTooltip=\\\"Zoom out\\\" matTooltipPosition=\\\"below\\\"\\n                    (click)=\\\"zoomOut()\\\">\\n                    <mat-icon>zoom_out</mat-icon>\\n                </button>\\n            </div>\\n            <div>\\n                <button mat-icon-button class=\\\"optionsButton\\\" matTooltip=\\\"Fit to screen\\\" matTooltipPosition=\\\"below\\\"\\n                    (click)=\\\"groupFocus()\\\">\\n                    <mat-icon>center_focus_strong</mat-icon>\\n                </button>\\n            </div>\\n            <div>\\n                <button mat-icon-button class=\\\"optionsButton\\\" matTooltip=\\\"Pan\\\" matTooltipPosition=\\\"below\\\" \\n                    (click)=\\\"togglePan()\\\" [style.color]=\\\" isDragButtonEnabled ? 'black':'lightgrey'\\\">\\n                    <mat-icon>pan_tool</mat-icon>\\n                </button>\\n            </div>\\n        </div>\\n    </div>\\n</div>\"","import { NodeStateInSearch } from './NodeStateInSearch';\nimport { SimulatorComponent } from 'src/app/simulator/simulator.component';\nimport { Solution } from './Solution';\nimport { BreadthFirstSolver } from './BreadthFirstSolver';\nimport { NodeStateInSearchColorMapper } from './NodeStateInSearchColorMapper';\nimport { PriorityQueue } from './PriorityQueue';\nimport { IQueue, Queue } from './Queue';\nimport { NodeType } from './UIElementNode';\n\nexport class BestFitSolver {\n\n    static Prepare(simulatorInstance: SimulatorComponent) {\n        Object.keys(simulatorInstance.nodes).forEach(nodeid => {\n            const node = simulatorInstance.nodes[nodeid];\n\n            // holds only the path cost\n            node.pathCost = Number.MAX_VALUE;\n\n            // initialize the current cost to max(therotically, infinity)\n            // this value can be the pathCost + heuristic(in case of A*) OR\n            // this value can a heurestic only(in greedy-best-fit)\n            node.cost = Number.MAX_VALUE;\n\n            // initialize the parent to null\n            node.parent = null;\n\n            // Mark if a node is visited\n            node.stateInSearch = NodeStateInSearch.NOT_VISITED;\n\n            // visit order\n            node.visitOrder = '';\n        });\n    }\n\n    static Solve(simulatorComponent: SimulatorComponent, weighDistanceToSource: boolean): Solution {\n        // if weighDistanceToSource is true, then the algorithm is A*, else it is greedy best-first\n\n        // TODO: Generalize code for this prep step\n        BestFitSolver.Prepare(simulatorComponent);\n\n        let visitOrder = 1;\n\n        debugger;\n        simulatorComponent.startNode.pathCost = 0; // the cost of the start node to itself will be zero\n        simulatorComponent.startNode.cost = simulatorComponent.distanceToNearestGoal(simulatorComponent.startNode);\n        simulatorComponent.startNode.stateInSearch = NodeStateInSearch.CURRENT; // mark the startNode as current-i.e. it is being visited right now, and\n        simulatorComponent.startNode.visitOrder = visitOrder;\n        // that some or all of its children are yet to be expanded\n\n        // For visual representation set the color as well\n        simulatorComponent.startNode.set({\n            stroke: NodeStateInSearchColorMapper.GetColorForCurrentNode(),\n            dirty: true\n        });\n\n        let queue: IQueue<any>;\n\n        const compareNodes = function(nodeA, nodeB) {\n            return nodeA.cost - nodeB.cost;\n        };\n\n        // use a priority queue if a uniform cost search is being used\n        queue = new PriorityQueue({ comparator: compareNodes });\n\n        queue.enqueue(simulatorComponent.startNode);\n\n        while (!queue.isEmpty()) {\n            const currentNode = queue.dequeue();\n            const nodeType: NodeType = currentNode.nodeType;\n            if (nodeType === NodeType.Goal) {\n                // create a solution object and tranverse through all the parents of the GOAL NODE\n                const sol: Solution = new Solution(currentNode.pathCost);\n                let tempNode = currentNode;\n                while (tempNode != null) {\n                    sol.addNodeToPath(tempNode);\n                    // find the edge connecting tempNode and tempNode.parent\n                    if (tempNode.parent != null) {\n                        const edgeConnectingParent = tempNode.getEdgeConnectingNode(tempNode.parent);\n                        sol.addEdgeToPath(edgeConnectingParent);\n                    }\n\n                    tempNode = tempNode.parent;\n                }\n                return sol;\n            }\n\n            // const edges = currentNode.asSource; // Get all the edges in which the node is a source\n            // const edgeIds = Object.keys(edges);\n\n            // Get all the neighbouring nodes\n            let neighbourData = currentNode.getAllNeighbouringNodesWithCost();\n            let neighbours = neighbourData['neighbours'];\n            let costs = neighbourData['costs'];\n\n            for (var i = 0; i < neighbours.length; i++) {\n                // const edge = edges[edgeId];\n                const nextNode = neighbours[i];\n                const cost = costs[i];\n                if (nextNode.stateInSearch === NodeStateInSearch.NOT_VISITED) {\n\n                    nextNode.pathCost = currentNode.pathCost + cost;\n\n                    if (weighDistanceToSource) {\n                        // for A*, the cost will be the path cost + the heurestic estimate from nextNode to the closest goal\n                        nextNode.cost = nextNode.pathCost + simulatorComponent.distanceToNearestGoal(nextNode);\n                    } else {\n                        // for greedy-best fit, the cost will be the heurestic estimate from the nextNode to the closest goal only\n                        nextNode.cost = simulatorComponent.distanceToNearestGoal(nextNode);\n                    }\n\n                    // set the parent of the nextNode\n                    nextNode.parent = currentNode;\n\n                    // set the state of the nextNode to seen or current\n                    nextNode.stateInSearch = NodeStateInSearch.CURRENT;\n\n                    nextNode.set({\n                        stroke: NodeStateInSearchColorMapper.GetColorForCurrentNode(),\n                        dirty: true\n                    });\n\n                    // enque the node for expansion\n                    queue.enqueue(nextNode);\n                }\n            }\n\n            // after all the nodes of the current node are expanded, we set the current state to visited\n            currentNode.stateInSearch = NodeStateInSearch.VISITED;\n            currentNode.set({\n                stroke: NodeStateInSearchColorMapper.GetColorForVisitedNode(),\n                dirty: true\n            });\n            currentNode.visitOrder = visitOrder++;\n        }\n\n        // if the queue is empty and a solution is not found till now, then there is no\n        // solution to the problem\n        return new Solution(Number.MAX_VALUE);\n    }\n}\n","import { QueueStrategy, Options, Comparator } from './PriorityQueue';\n\nexport default class BinaryHeapStrategy<T> implements QueueStrategy<T> {\n\n    private comparator: Comparator<T>;\n    private data: T[];\n\n    constructor(options: Options<T>) {\n        this.comparator = options.comparator;\n        this.data = options.initialValues ? options.initialValues.slice(0) : [];\n        this._heapify();\n    }\n\n    private _heapify() {\n        if (this.data.length > 0) {\n            for (let i = 0; i < this.data.length; i++) {\n                this._bubbleUp(i);\n            }\n        }\n    }\n\n    public enqueue(value: T) {\n        this.data.push(value);\n        this._bubbleUp(this.data.length - 1);\n    }\n\n    public dequeue(): T {\n        const ret = this.data[0];\n        const last = this.data.pop();\n        if (this.data.length > 0 && last !== undefined) {\n            this.data[0] = last;\n            this._bubbleDown(0);\n        }\n        return ret;\n    }\n\n    public peek(): T {\n        return this.data[0];\n    }\n\n    public clear() {\n        this.data.length = 0;\n    }\n\n    public _bubbleUp(pos: number): any {\n        while (pos > 0) {\n            // tslint:disable-next-line: no-bitwise\n            const parent = (pos - 1) >>> 1;\n            if (this.comparator(this.data[pos], this.data[parent]) < 0) {\n                const x = this.data[parent];\n                this.data[parent] = this.data[pos];\n                this.data[pos] = x;\n                pos = parent;\n            } else {\n                break;\n            }\n        }\n    }\n\n    public _bubbleDown(pos: number) {\n        const last = this.data.length - 1;\n        while (true) {\n            // tslint:disable-next-line: no-bitwise\n            const left = (pos << 1) + 1;\n            const right = left + 1;\n            let minIndex = pos;\n            if (left <= last && this.comparator(this.data[left], this.data[minIndex]) < 0) {\n                minIndex = left;\n            }\n            if (right <= last && this.comparator(this.data[right], this.data[minIndex]) < 0) {\n                minIndex = right;\n            }\n            if (minIndex !== pos) {\n                const x = this.data[minIndex];\n                this.data[minIndex] = this.data[pos];\n                this.data[pos] = x;\n                pos = minIndex;\n            } else {\n                break;\n            }\n        }\n        return void 0;\n    }\n\n    public refreshQueueOrder() {\n        this._heapify();\n    }\n}\n","import { SimulatorComponent } from 'src/app/simulator/simulator.component';\nimport { NodeStateInSearch } from './NodeStateInSearch';\nimport { Queue, IQueue } from './Queue';\nimport { NodeStateInSearchColorMapper } from './NodeStateInSearchColorMapper';\nimport { NodeColorMapper } from './UIElementNode';\n\nexport class BipartiteChecker {\n\n    // This function does the following\n    // 1) Checks if the graph is bipartite or not\n    // 2) Colors the nodes using two colors\n    // 3) Arranges the parts by row\n    static SolveBipartiteProblem(simulatorInstance: SimulatorComponent) : any{\n        let biPartiteState = BipartiteChecker.GetParts(simulatorInstance);\n        console.log(biPartiteState);\n        if(biPartiteState == null){\n            let result = {message: 'The graph is not bipartite'}\n            return result;\n        }\n        else{\n            BipartiteChecker.ColorNodesByParts(simulatorInstance, biPartiteState);\n            return {message:\"The graph is Bipartite. Two parts have been colored.\"}\n        }\n    }\n\n    static ColorNodesByParts(simulatorInstance: SimulatorComponent, parts: any) {\n        debugger\n        let part0 = parts[0]\n        let part1 = parts[1]\n        \n        for (var key in part0) {\n            if (part0.hasOwnProperty(key)) {\n                part0[key].set({\n                    fill: '#008000',\n                    dirty: true\n                });\n            }\n        }\n\n        for(var key in part1){\n            if(part1.hasOwnProperty(key)){\n                part1[key].set({\n                    fill: '#808080',\n                    dirty: true\n                });\n            }\n        }\n\n        simulatorInstance.canvas.requestRenderAll();\n    }\n    \n    static GetParts(simulatorInstance: SimulatorComponent) {\n        Object.keys(simulatorInstance.nodes).forEach(nodeid => {\n            const node = simulatorInstance.nodes[nodeid];\n            // Mark the node as unvisited\n            node.stateInSearch = NodeStateInSearch.NOT_VISITED;\n            \n            node.set({\n                fill: NodeColorMapper.GetIntermediateNodeColor(),\n                dirty: true\n            });\n            \n        });\n\n        simulatorInstance.canvas.requestRenderAll();\n\n        let queue: IQueue<any>;\n        queue = new Queue<any>();\n        let part0 = {};\n        let part1 = {};\n\n        let nodes = simulatorInstance.nodes\n        const nodeIds = Object.keys(nodes);\n\n        // Add any node to the queue\n        queue.enqueue(nodes[nodeIds[0]]);\n\n        // Assign this node to part0\n        part0[nodeIds[0]] = nodes[nodeIds[0]]\n        var colorForNeighbours: number = 0;\n\n        while(!queue.isEmpty()){\n            // pop the topNode\n            debugger;\n            let topNode = queue.dequeue();\n            var isInPart0: boolean = topNode['id'] in part0;\n            var isInPart1: boolean = topNode['id'] in part1;\n            if(isInPart0){\n                colorForNeighbours = 1;\n            }else{\n                // has to be in part1, i.e has to be in either of the two\n                colorForNeighbours = 0;\n            }\n\n            var neighbouringNodes = topNode.getAllNeighbouringNodes();\n            \n            for(let i = 0; i < neighbouringNodes.length; i++){\n                let adjNode = neighbouringNodes[i];\n                \n                // Check if the adjNode is visited\n                var isAdjInPart0 = adjNode['id'] in part0;\n                var isAdjInPart1 = adjNode['id'] in part1;\n\n                if(!isAdjInPart0 && !isAdjInPart1){\n                    // adjNode has not been seen as yet\n                    if(colorForNeighbours == 0){\n                        part0[adjNode.id] = adjNode;\n                    }else{\n                        part1[adjNode.id] = adjNode;\n                    }\n                    queue.enqueue(adjNode);\n                }else if(adjNode['id'] in part0){\n                    \n                    if(colorForNeighbours == 0){\n                        continue;\n                    }else{\n                        return null;\n                    }\n                    \n                }else if(adjNode['id'] in part1){\n\n                    if(colorForNeighbours == 1){\n                        continue;\n                    }else{\n                        return null;\n                    }\n\n                }else{\n                    // this will never happen\n                    // a node will either be in part0 or part1\n                }\n\n            }\n        }\n\n        let result = []\n        result.push(part0)\n        result.push(part1)\n        console.log(\"Part 0:\");\n        console.log(part0);\n        console.log(\"Part 1\");\n        console.log(part1);\n        debugger;\n        return result;\n    }\n}","import { NodeStateInSearch } from './NodeStateInSearch';\nimport { SimulatorComponent } from 'src/app/simulator/simulator.component';\nimport { Queue, IQueue } from './Queue';\nimport { NodeType } from './UIElementNode';\nimport { NodeStateInSearchColorMapper } from './NodeStateInSearchColorMapper';\nimport { Solution } from './Solution';\nimport { PriorityQueue } from './PriorityQueue';\nimport { Options } from './PriorityQueue';\n\nexport class BreadthFirstSolver {\n\n    static Prepare(simulatorInstance: SimulatorComponent) {\n\n        Object.keys(simulatorInstance.nodes).forEach(nodeid => {\n            const node = simulatorInstance.nodes[nodeid];\n\n            // initialize the current cost to max(therotically, infinity)\n            node.cost = Number.MAX_VALUE;\n\n            // initialize the parent to null\n            node.parent = null;\n\n            // Mark if a node is visited\n            node.stateInSearch = NodeStateInSearch.NOT_VISITED;\n\n            node.visitOrder = '';\n        });\n\n    }\n\n    static Solve(simulatorComponent: SimulatorComponent): Solution {\n        BreadthFirstSolver.Prepare(simulatorComponent);\n\n        let visitOrder = 1;\n\n        simulatorComponent.startNode.cost = 0; // the cost of the start node to itself will be zero\n        simulatorComponent.startNode.stateInSearch = NodeStateInSearch.CURRENT; // mark the startNode as current-i.e. it is being visited right now, and\n        // that some or all of its children are yet to be expanded\n        simulatorComponent.startNode.visitOrder = visitOrder;\n\n        // For visual representation set the color as well\n        simulatorComponent.startNode.set({\n            stroke: NodeStateInSearchColorMapper.GetColorForCurrentNode(),\n            dirty: true\n        });\n\n        let queue: IQueue<any>;\n        queue = new Queue<any>(); // use a normal queue if normal BFS is to be used\n\n        queue.enqueue(simulatorComponent.startNode);\n\n        while (!queue.isEmpty()) {\n            const currentNode = queue.dequeue();\n            const nodeType: NodeType = currentNode.nodeType;\n            if (nodeType === NodeType.Goal) {\n                // create a solution object and tranverse through all the parents of the GOAL NODE\n                const sol: Solution = new Solution(currentNode.cost);\n                let tempNode = currentNode;\n                while (tempNode != null) {\n                    sol.addNodeToPath(tempNode);\n                    // find the edge connecting tempNode and tempNode.parent\n                    if (tempNode.parent != null) {\n                        const edgeConnectingParent = tempNode.getEdgeConnectingNode(tempNode.parent);\n                        sol.addEdgeToPath(edgeConnectingParent);\n                    }\n\n                    tempNode = tempNode.parent;\n                }\n                return sol;\n            }\n\n            // Get all the neighbouring nodes\n            let neighbours = currentNode.getAllNeighbouringNodes();\n\n            // const edges = currentNode.asSource; // Get all the edges in which the node is a source\n            // const edgeIds = Object.keys(edges);\n            for (const nextNode of neighbours) {\n                // const edge = edges[edgeId];\n                //const nextNode = edge.destination;\n                if (nextNode.stateInSearch === NodeStateInSearch.NOT_VISITED) {\n\n                    // as the nextNode is one step away from the currentNode, just add 1 to the currentNode's path cost from source\n                    nextNode.cost = currentNode.cost + 1;\n\n                    // set the parent of the nextNode\n                    nextNode.parent = currentNode;\n\n                    // set the state of the nextNode to seen or current\n                    nextNode.stateInSearch = NodeStateInSearch.CURRENT;\n\n                    nextNode.set({\n                        stroke: NodeStateInSearchColorMapper.GetColorForCurrentNode(),\n                        dirty: true\n                    });\n\n                    // enque the node for expansion\n                    queue.enqueue(nextNode);\n                }\n            }\n\n            // after all the nodes of the current node are expanded, we set the current state to visited\n            currentNode.stateInSearch = NodeStateInSearch.VISITED;\n            currentNode.set({\n                stroke: NodeStateInSearchColorMapper.GetColorForVisitedNode(),\n                dirty: true\n            });\n            currentNode.visitOrder = visitOrder++;\n        }\n\n        // if the queue is empty and a solution is not found till now, then there is no\n        // solution to the problem\n        return new Solution(Number.MAX_VALUE);\n    }\n}\n","import { NodeStateInSearch } from './NodeStateInSearch';\nimport { SimulatorComponent } from 'src/app/simulator/simulator.component';\nimport { Queue, IQueue } from './Queue';\nimport { NodeType } from './UIElementNode';\nimport { NodeStateInSearchColorMapper } from './NodeStateInSearchColorMapper';\nimport { Solution } from './Solution';\nimport { PriorityQueue } from './PriorityQueue';\nimport { Options } from './PriorityQueue';\nimport { XY } from './XY';\nimport { UIElementEdge } from './UIElementEdge';\n\nexport class ConvexHull {\n    \n    static Find(simulatorInstance: SimulatorComponent): any{\n        \n        debugger;\n\n        simulatorInstance.deleteAllEdges();\n\n        let nodeIds = Object.keys(simulatorInstance.nodes)\n        let nodes = []\n        let leftMostPoint = null\n        let leftX = Number.MAX_VALUE;\n        // find the left-most point\n        for(var i = 0; i < nodeIds.length; i++){\n            nodes.push(simulatorInstance.nodes[nodeIds[i]])\n            if(nodes[i].left < leftX){\n                leftMostPoint = nodes[i]\n                leftX = nodes[i].left;\n            }\n        }\n\n        if(leftMostPoint == null){\n            return {'message': 'Something went wrong!'}\n        }\n        let hull = []\n        let start = leftMostPoint;\n        hull.push(start);\n        let current = start;\n        let nextPoint = null\n        do{\n            nextPoint = this.getNextPoint(current, simulatorInstance.nodes);\n            hull.push(nextPoint);\n            current = nextPoint;\n        }while(nextPoint.id != start.id);\n        \n        hull.push(start)\n        for(var i = 0; i < hull.length-1; i++){\n            const edge = new UIElementEdge([hull[i].left, hull[i].top, hull[i+1].left, hull[i+1].top],\n                {\n                  id: simulatorInstance.idGenerator.generateNew(),\n                  source: hull[i],\n                  destination: hull[i+1],\n                  isUndirected: true\n                }\n              );\n              simulatorInstance.registerNodeInEdge(edge, hull[i], hull[i+1], true);\n        }\n\n        simulatorInstance.canvas.requestRenderAll();\n\n        return {\n            'message': 'Convex-hull found!'\n        }\n    }\n\n    static getNextPoint(current, nodesSet){\n        delete nodesSet[current.id]\n        let nodeIds = Object.keys(nodesSet)\n        let nextNode = nodesSet[nodeIds[0]]\n        let currVect = new XY(nextNode.left - current.left, nextNode.top - current.top)\n        for(var i = 1; i < nodeIds.length; i++){\n            let newCand = nodesSet[nodeIds[i]]\n            let newVect = new XY(newCand.left - current.left, newCand.top - current.top)\n            let cp = currVect.crossProduct(newVect)\n            if(cp > 0){\n                nextNode = newCand;\n                currVect = newVect;\n            }\n        }\n        nodesSet[current.id] = current;\n        return nextNode;\n    }\n\n}\n","import { SimulatorComponent } from './../app/simulator/simulator.component';\nimport { NodeStateInSearchColorMapper } from './NodeStateInSearchColorMapper';\nimport { Solution } from './Solution';\nimport { XY } from './XY';\n\nexport class DepthFirstSolver {\n\n    static Solve(simulatorInstance: SimulatorComponent, currentState: Solution, bestState: Solution, solveOptimally: boolean): any {\n\n        const currentNode = currentState.currentNode;\n        // mark the current node as visited\n        currentNode.set(\n            {\n                stroke : NodeStateInSearchColorMapper.GetColorForVisitedNode(),\n                dirty : true\n            }\n        );\n        simulatorInstance.canvas.requestRenderAll();\n\n        if (currentState.reachedGoalState()) {\n            if (solveOptimally) {\n                if (currentState.cost < bestState.cost) {\n                    bestState.applyState(currentState);\n                    return {\n                        continueSearch: true,\n                        solutionFound: true,\n                        message: 'Solution found with a path cost of :' + currentState.cost\n                    };\n                } else {\n                    return {\n                        continueSearch: true,\n                        solutionFound: true,\n                        message: 'Better solution exists with a path cost of :' + bestState.cost\n                    };\n                }\n            } else {\n                bestState.applyState(currentState);\n                return {\n                    continueSearch: false,\n                    solutionFound: true,\n                    message: 'Solution found with a path cost of :' + currentState.cost\n                };\n            }\n        }\n\n        // const connectedEdges = currentState.getNextEdges();\n        // const connectedEdgeIds = Object.keys(connectedEdges);\n\n        let neighbourData = currentNode.getAllNeighbourData();\n        let neighbours = neighbourData['neighbours'];\n        let costs = neighbourData['costs'];\n        let edges = neighbourData['edges'];\n\n        for (var i = 0; i < neighbours.length; i++) {\n            // const nextEdge = connectedEdges[edgeId];\n            const nextNode = neighbours[i];\n            const edgeCost = costs[i];\n            const nextEdge = edges[i];\n\n            if (currentState.isNodeConsideredInPath(nextNode)) {\n                continue; // do not consider a node that has already been considered to avoid infinite loops\n            }\n\n            // forward track\n            currentState.setCurrentNode(nextNode);\n            currentState.addNodeToPath(nextNode);\n            currentState.addEdgeToPath(nextEdge);\n            currentState.addCost(edgeCost);\n\n            const result = this.Solve(simulatorInstance, currentState, bestState, solveOptimally);\n\n            // backtrack\n            currentState.setCurrentNode(currentNode);\n            currentState.removeNodeFromPath(nextNode);\n            currentState.removeEdgeFromPath(nextEdge);\n            currentState.deductCost(edgeCost);\n\n            if (!result.continueSearch) {\n                // if in any one of the child node expansion, continueSearch is set to false, further child exploration should be stopped.\n                return result;\n            }\n\n        }\n\n        // executed when all the children have been expanded.\n        // if a solution has been found till now, then information related to that will be returned.\n        // we need to always set continueSearch to true because the execution will come here only when we are running in \n        // optimal = true setting and in that case we need to continue search even we have found a solution\n        return {\n            continueSearch: true,\n            solutionFound: bestState.isSolutionFound(),\n            message: bestState.isSolutionFound() ? 'Best solution till now found with a cost of ' + bestState.cost : 'Best solution not found till now'\n        };\n    }\n}\n","import { SimulatorComponent } from 'src/app/simulator/simulator.component';\nimport { BipartiteChecker } from \"./BipartiteChecker\";\n\nexport class GeneralAlgorithms{\n    /*\n    This function is used to order the graph topologically\n    */\n    static TopologicalSorting(simulatorInstance: SimulatorComponent) : any{\n        \n    }\n    \n    /*\n    This function is used to check if a graph is bipartite or not\n    */\n    static CheckIfBipartite(simulatorInstance: SimulatorComponent) : any{\n        return BipartiteChecker.SolveBipartiteProblem(simulatorInstance);\n    }   \n}","import { NodeStateInSearch } from './NodeStateInSearch';\nimport { SimulatorComponent } from 'src/app/simulator/simulator.component';\nimport { Queue, IQueue } from './Queue';\nimport { NodeType } from './UIElementNode';\nimport { NodeStateInSearchColorMapper } from './NodeStateInSearchColorMapper';\nimport { Solution } from './Solution';\nimport { PriorityQueue } from './PriorityQueue';\nimport { Options } from './PriorityQueue';\nimport { SearchSolvers } from './SearchSolvers';\n\nexport class GraphBridges {\n\n    static Prepare(simulatorInstance: SimulatorComponent) {\n\n        Object.keys(simulatorInstance.nodes).forEach(nodeid => {\n            const node = simulatorInstance.nodes[nodeid];\n\n            // initialize the parent to null\n            node.parent = null;\n\n            // Mark if a node is visited\n            node.stateInSearch = NodeStateInSearch.NOT_VISITED;\n\n            node.level = 0;\n        });\n\n    }\n\n    static Identify(simulatorComponent: SimulatorComponent): any {\n        GraphBridges.Prepare(simulatorComponent);\n        SearchSolvers.PrepareForSearch(simulatorComponent);\n        let allBridges = []\n\n        let nodeList: any[] = [];\n        const nodeIds = Object.keys(simulatorComponent.nodes);\n        for (const nodeId of nodeIds) {\n            const node = simulatorComponent.nodes[nodeId];\n            nodeList.push(node);\n        }\n        debugger\n        nodeList.forEach(node => {\n            if(node.stateInSearch == NodeStateInSearch.NOT_VISITED){\n                node.level = 0;\n                let bridges = []\n                GraphBridges.subTreeIdenfity(simulatorComponent, node, bridges);\n\n                bridges.forEach(bridge => {\n                    allBridges.push(bridge);\n                });\n            }\n        });\n        let result = {}\n        if(allBridges.length == 0){\n            result['message'] = 'There are no bridges in the graph!'\n        }else{\n            // mark bridges in the graph\n\n            allBridges.forEach(bridge => {\n                bridge.set({\n                    stroke: '#00FF00',\n                    dirty : true\n                });\n            });\n            simulatorComponent.canvas.requestRenderAll();\n            result['message'] = \"Bridges have been colored in the graph!\"\n        }\n        return result;\n    }\n\n    static subTreeIdenfity(simulatorComponent: SimulatorComponent, node: any, bridges: any[]){\n        node.stateInSearch = NodeStateInSearch.VISITED;\n        node.H = Number.MAX_VALUE;\n\n        let neighbourData = node.getAllNeighbourData();\n        let neighbours = neighbourData['neighbours'];\n        let edges = neighbourData['edges']\n\n        for(var i = 0; i < neighbours.length; i++){\n            let u = neighbours[i];\n            if(u.stateInSearch == NodeStateInSearch.NOT_VISITED){\n                u.level = node.level + 1;\n                GraphBridges.subTreeIdenfity(simulatorComponent, u, bridges);\n                if(u.H >= u.level){\n                    bridges.push(edges[i]);\n                }\n\n                if(u.H < node.H){\n                    node.H = u.H;\n                }\n            }\n            else if(u.level < node.level - 1){\n                if(u.level < node.H){\n                    node.H = u.level;\n                }\n            }\n        }\n\n    }\n}\n","import { Utility } from './Utility';\n\nexport class IdGenerator{\n    private largestNumber : number;\n    private idsGenerated : {};\n\n    constructor(largestNumber: number){\n        this.largestNumber = largestNumber;\n        this.idsGenerated = {};\n    }\n    \n    generateNew(){\n        var id;\n        do{\n            id = Utility.GenerateRandomNumberBetween(0, this.largestNumber);\n        }while(this.idsGenerated[id] != null);\n        return id;\n    }\n\n}","export enum NodeStateInSearch {\n    VISITED = 'VISITED',\n    CURRENT = 'CURRENT',\n    NOT_VISITED = 'NOT_VISITED'\n}\n","export class NodeStateInSearchColorMapper{\n    private static COLOR_MAP = {\n        \"CURRENT\" : \"#000\",\n        \"VISITED\" : \"#F7F701\",\n        \"NOT_VISITED\" : \"#FFF\"\n    }\n\n    public static GetColorForCurrentNode() : string{\n        return this.COLOR_MAP['CURRENT'];\n    }\n\n    public static GetColorForVisitedNode() : string{\n        return this.COLOR_MAP['VISITED'];\n    }\n\n    public static GetColorForNotVisitedNode() : string{\n        return this.COLOR_MAP['NOT_VISITED'];\n    }\n\n}","import { IQueue } from './Queue';\nimport BinaryHeapStrategy from './BinaryHeapStrategy';\n\nexport type Comparator<T> = (a: T, b: T) => number;\n\nexport interface Options<T> {\n    comparator: Comparator<T>;\n    initialValues?: T[];\n}\n\nexport interface QueueStrategy<T> {\n    enqueue(value: T): void;\n    dequeue(): T;\n    peek(): T;\n    clear(): void;\n    refreshQueueOrder(): void;\n}\n\nexport class PriorityQueue<T> implements IQueue<T> {\n    private len = 0;\n    public get length() { return this.len; }\n\n    private strategy: QueueStrategy<T>;\n\n    public constructor(options: Options<T>) {\n        this.len = options.initialValues ? options.initialValues.length : 0;\n        this.strategy = new BinaryHeapStrategy(options);\n    }\n\n    public enqueue(value: T) {\n        this.len++;\n        this.strategy.enqueue(value);\n    }\n\n    public dequeue() {\n        if (!this.len) { throw new Error('Empty queue'); }\n        this.len--;\n        return this.strategy.dequeue();\n    }\n\n    public peek() {\n        if (!this.len) { throw new Error('Empty queue'); }\n        return this.strategy.peek();\n    }\n\n    public clear() {\n        this.len = 0;\n        this.strategy.clear();\n    }\n\n    public isEmpty(): boolean {\n        return this.len === 0;\n    }\n\n    public heapify() {\n        this.strategy.refreshQueueOrder();\n    }\n}\n\n\n\n","export interface IQueue<T> {\n    enqueue(item: T): void;\n    dequeue(): T;\n    peek(): T;\n    clear(): void;\n    isEmpty(): boolean;\n}\n\nexport class Queue<T> implements IQueue<T> {\n    queue: T[];\n\n    constructor(queue?: T[]) {\n        this.queue = queue || [];\n    }\n\n    public enqueue(item: T) {\n        this.queue.push(item);\n    }\n\n    public dequeue(): T {\n        return this.queue.shift();\n    }\n\n    public peek(): T {\n        return this.queue[0];\n    }\n\n    public clear() {\n        this.queue = [];\n    }\n\n    public count(): number {\n        return this.queue.length;\n    }\n\n    isEmpty(): boolean {\n        return(this.count() === 0);\n    }\n}\n","import { BestFitSolver } from './BestFitSolver';\nimport { BreadthFirstSolver } from './BreadthFirstSolver';\nimport { SimulatorComponent } from 'src/app/simulator/simulator.component';\nimport { DepthFirstSolver } from './DepthFirstSolver';\nimport { NodeStateInSearchColorMapper } from './NodeStateInSearchColorMapper';\nimport { Utility } from './Utility';\nimport { Solution } from './Solution';\nimport { UniformCostSolver } from './UniformCostSolver';\n\nexport class SearchSolvers {\n\n    static ValidateGraph(simulatorInstance: SimulatorComponent): any {\n\n        let result = {\n            isValid : false,\n            message : ''\n        };\n        debugger;\n        if (Object.keys(simulatorInstance.nodes).length === 0) {\n            result.isValid = false;\n            result.message = 'Please add some nodes to the graph';\n            return result;\n        }\n\n        if (simulatorInstance.startNode != null && Object.keys(simulatorInstance.goalNodes).length !== 0) {\n            result.isValid = true;\n            result.message = '';\n        } else if (simulatorInstance.startNode != null && Object.keys(simulatorInstance.goalNodes).length === 0) {\n            result.isValid = false;\n            result.message = 'Graph not valid: Graph should have at least one goal node';\n        } else if (simulatorInstance.startNode == null && Object.keys(simulatorInstance.goalNodes).length !== 0) {\n            result.isValid = false;\n            result.message = 'Graph not valid: Start node is not defined';\n        } else {\n            result.isValid = false;\n            result.message = 'Graph not valid: Start, End nodes are not defined';\n        }\n        return result;\n    }\n\n    static SolveByBreadthFirst(simulatorComponent: SimulatorComponent): any {\n\n        SearchSolvers.PrepareForSearch(simulatorComponent);\n        let solution: Solution;\n        solution = BreadthFirstSolver.Solve(simulatorComponent);\n        const solFound = solution.isSolutionFound();\n        const result = {\n            solutionFound: solFound,\n            message: solFound ? 'Solution found with a cost of: ' + solution.cost : 'Could not find the solution'\n        };\n\n        const nodeList: any = solution.getNodeListInPath();\n        nodeList.forEach(node => {\n            node.set({\n                stroke: '#00FF00',\n                dirty: true\n            });\n        });\n\n        const edgeList: any = solution.getEdgeListInPath();\n        edgeList.forEach(edge => {\n            edge.set({\n                stroke: '#00FF00',\n                dirty: true\n            });\n        });\n        simulatorComponent.canvas.requestRenderAll();\n        return result;\n    }\n\n    static SolveByDepthFirst(simulatorInstance: SimulatorComponent, solveOptimally: boolean): any {\n\n        let result = {\n            solutionFound : false,\n            message : ''\n        };\n\n        SearchSolvers.PrepareForSearch(simulatorInstance);\n\n        let currentSolution: Solution = new Solution(0);\n        currentSolution.setCurrentNode(simulatorInstance.startNode);\n        currentSolution.addNodeToPath(simulatorInstance.startNode);\n\n        let bestSolution: Solution = new Solution(Number.MAX_VALUE);\n\n        DepthFirstSolver.Solve(simulatorInstance, currentSolution, bestSolution, solveOptimally);\n\n        const edges: any[] = bestSolution.getEdgeListInPath();\n        const nodes: any[] = bestSolution.getNodeListInPath();\n\n        if (edges.length == 0) {\n            result.solutionFound = false;\n            result.message = 'Could not find the solution';\n            return result;\n        }\n\n        result.solutionFound = true;\n        result.message = 'Best solution found with path cost: ' + bestSolution.cost;\n\n        nodes.forEach(node => {\n            node.set({\n                stroke: '#00FF00',\n                dirty : true\n            });\n        });\n\n        edges.forEach(edge => {\n            edge.set({\n                stroke: '#00FF00',\n                dirty : true\n            });\n        });\n        simulatorInstance.canvas.requestRenderAll();\n        \n        return result;\n    }\n\n    static SolveByBestFit(simulatorComponent: SimulatorComponent, isAStarSearch: boolean) {\n        SearchSolvers.PrepareForSearch(simulatorComponent);\n        let solution: Solution;\n        if (isAStarSearch) {\n             solution = BestFitSolver.Solve(simulatorComponent, true);\n        } else {\n            solution = BestFitSolver.Solve(simulatorComponent, false);\n        }\n\n        const solFound = solution.isSolutionFound();\n        const result = {\n            solutionFound: solFound,\n            message: solFound ? 'Solution found with a cost of: ' + solution.cost : 'Could not find the solution'\n        };\n\n        const nodeList: any = solution.getNodeListInPath();\n        nodeList.forEach(node => {\n            node.set({\n                stroke: '#00FF00',\n                dirty: true\n            });\n        });\n\n        const edgeList: any = solution.getEdgeListInPath();\n        edgeList.forEach(edge => {\n            edge.set({\n                stroke: '#00FF00',\n                dirty: true\n            });\n        });\n        simulatorComponent.canvas.requestRenderAll();\n        return result;\n    }\n\n    static SolveByUniformCostSearch(simulatorComponent: SimulatorComponent): any {\n        SearchSolvers.PrepareForSearch(simulatorComponent);\n        let solution: Solution;\n\n        solution = UniformCostSolver.Solve(simulatorComponent);\n\n        const solFound = solution.isSolutionFound();\n        const result = {\n            solutionFound: solFound,\n            message: solFound ? 'Solution found with a cost of: ' + solution.cost : 'Could not find the solution'\n        };\n\n        const nodeList: any = solution.getNodeListInPath();\n        nodeList.forEach(node => {\n            node.set({\n                stroke: '#00FF00',\n                dirty: true\n            });\n        });\n\n        const edgeList: any = solution.getEdgeListInPath();\n        edgeList.forEach(edge => {\n            edge.set({\n                stroke: '#00FF00',\n                dirty: true\n            });\n        });\n        simulatorComponent.canvas.requestRenderAll();\n        return result;\n    }\n\n    static PrepareForSearch(simulatorInstance: SimulatorComponent) {\n      let notVisitedNodeColor = NodeStateInSearchColorMapper.GetColorForNotVisitedNode();\n      Object.keys(simulatorInstance.nodes).forEach(nodeid => {\n          var node = simulatorInstance.nodes[nodeid];\n          node.set({\n              stroke : notVisitedNodeColor,\n              strokeWidth : 4,\n              dirty: true\n          });\n        });\n\n      Object.keys(simulatorInstance.edges).forEach(edgeId => {\n          var edge = simulatorInstance.edges[edgeId];\n          edge.set({\n              stroke: '#FFFFFF',\n              dirty: true\n          });\n      });\n\n      simulatorInstance.canvas.requestRenderAll();\n\n    }\n\n}\n","import { NodeType } from './UIElementNode';\n\nexport class Solution {\n    public currentNode;\n    public nodesInPath;\n    public edgesInPath;\n    public cost: number;\n\n    constructor(cost) {\n        this.currentNode = {};\n        this.nodesInPath = {};\n        this.edgesInPath = {};\n        this.cost = cost;\n    }\n\n    public reachedGoalState(): boolean {\n        const nodeType: NodeType = this.currentNode.nodeType;\n        return (nodeType === NodeType.Goal);\n    }\n\n    public applyState(otherSolution: Solution) {\n        this.cost = otherSolution.cost;\n        this.currentNode = otherSolution.currentNode;\n\n        this.nodesInPath = {}; // create a new object to add nodes as key value pairs\n        // iterate over all the otherSolution's nodes and add them to the current solution\n        const nodeIds = Object.keys(otherSolution.nodesInPath);\n        for (const nodeId of nodeIds) {\n            const node = otherSolution.nodesInPath[nodeId];\n            this.nodesInPath[nodeId] = node;\n        }\n\n        this.edgesInPath = {}; // create a new object to add edges as key value pairs\n        const edgeIds = Object.keys(otherSolution.edgesInPath);\n        for (const edgeId of edgeIds) {\n            const edge = otherSolution.edgesInPath[edgeId];\n            this.edgesInPath[edgeId] = edge;\n        }\n    }\n\n    public getNextEdges(): any {\n        return this.currentNode.asSource;\n    }\n\n    public isNodeConsideredInPath(node): boolean {\n        return (this.nodesInPath[node.id]);\n    }\n\n    public setCurrentNode(node: any) {\n        this.currentNode = node;\n    }\n\n    public addNodeToPath(node: any) {\n        this.nodesInPath[node.id] = node;\n    }\n\n    public addEdgeToPath(edge: any) {\n        this.edgesInPath[edge.id] = edge;\n    }\n\n    addCost(cost: number) {\n        this.cost += cost;\n    }\n\n    removeNodeFromPath(nodeToRemove: any) {\n        delete this.nodesInPath[nodeToRemove.id];\n    }\n\n    removeEdgeFromPath(edgeToRemove: any) {\n        delete this.edgesInPath[edgeToRemove.id];\n    }\n\n    deductCost(cost: number) {\n        this.cost -= cost;\n    }\n\n    public getNodeListInPath(): any[] {\n        let nodeList: any[] = [];\n        const nodeIds = Object.keys(this.nodesInPath);\n        for (const nodeId of nodeIds) {\n            const node = this.nodesInPath[nodeId];\n            nodeList.push(node);\n        }\n        return nodeList;\n    }\n\n    public getEdgeListInPath(): any[] {\n        let edgeList: any[] = [];\n        const edgeIds = Object.keys(this.edgesInPath);\n        for (const edgeId of edgeIds) {\n            const node = this.edgesInPath[edgeId];\n            edgeList.push(node);\n        }\n        return edgeList;\n    }\n\n    public isSolutionFound() {\n        return (Object.keys(this.edgesInPath).length !== 0);\n    }\n}\n","import { SimulatorComponent } from 'src/app/simulator/simulator.component';\nimport { NodeStateInSearch } from './NodeStateInSearch';\nimport { Queue, IQueue } from './Queue';\nimport { NodeStateInSearchColorMapper } from './NodeStateInSearchColorMapper';\nimport { NodeColorMapper } from './UIElementNode';\n\nexport class TopologicalSorting{\n\n    static Sort(simulatorInstance: SimulatorComponent) : any{\n        let incomingEdges = {};\n        let nodeIds = Object.keys(simulatorInstance.nodes);\n        let queue: IQueue<any>;\n        queue = new Queue<any>();\n        debugger;\n        for(let i = 0; i < nodeIds.length; i++)\n        {\n            let nodeId = nodeIds[i];\n            let node = simulatorInstance.nodes[nodeId];\n            let parentNodes = simulatorInstance.getSourceNodesFor(node);\n            incomingEdges[nodeId] = parentNodes.length;\n            if(parentNodes.length == 0){\n                queue.enqueue(node);\n            }\n        }\n\n        let orderQueue: IQueue<any>;\n        orderQueue = new Queue<any>();\n\n        let inOrder = 0;\n        while(!queue.isEmpty()){\n            let node = queue.dequeue();\n            orderQueue.enqueue(node);\n            let destinations = simulatorInstance.getDestinationNodesFor(node);\n            inOrder++;\n\n            for(let i = 0; i < destinations.length; i++){\n                let destinationNodeId = destinations[i].id;\n                incomingEdges[destinationNodeId] = incomingEdges[destinationNodeId] - 1;\n                if(incomingEdges[destinationNodeId] == 0){\n                    queue.enqueue(destinations[i]);\n                }\n            }\n        }\n\n        if(inOrder == nodeIds.length){\n            // order nodes in topological order\n            let x = 0;\n            while(!orderQueue.isEmpty())\n            {\n                let node = orderQueue.dequeue();\n                node.set({\n                    left: x,\n                    top: Math.random() * 120,\n                    dirty: true\n                });\n                x+= 300;\n\n                // iterate over all the asSource edges\n                simulatorInstance.objectKeys(node.asSource).forEach(edgeKey => {\n                    let edge = node.asSource[edgeKey];\n                    edge.set({\n                    x1: node.left,\n                    y1: node.top,\n                    dirty: true\n                    });\n                });\n        \n                // iterate over all the asDestination edges\n                simulatorInstance.objectKeys(node.asDestination).forEach(edgeKey => {\n                    let edge = node.asDestination[edgeKey];\n                    edge.set({\n                    x2: node.left,\n                    y2: node.top,\n                    dirty: true\n                    });\n                });\n                \n            }\n            simulatorInstance.canvas.requestRenderAll();\n            simulatorInstance.groupFocus();\n            simulatorInstance.zoomOutBy(0.4);\n        }\n\n        let result = {};\n        if(inOrder < nodeIds.length){\n            result['message'] = 'Topological ordering is not valid for the graph.'\n        }else{\n            result['message'] = 'Nodes have been sorted topologically from left ro right.'\n            result['message'] += ' They have been staggered randomly for better edge visibility.'\n        }\n\n        console.log(incomingEdges);\n        return result;\n    }\n}","import 'fabric';\nimport { XY } from './XY';\n\ndeclare let fabric;\n\nexport let UIElementEdge = fabric.util.createClass(fabric.Line, {\n\n  type: 'UIElementEdge',\n\n  initialize(element, options) {\n    options || (options = {});\n    this.callSuper('initialize', element, options);\n\n    // this is the Id of the edge\n    this.set('id', options.id || -1);\n\n    // this is the source node in the edge\n    this.set('source', options.source || null);\n\n    // this is the destination node in the edge\n    this.set('destination', options.destination || null);\n\n    // this decides the amount of weight to be given to the edge length\n    this.set('edgeWeight', options.edgeWeight || 1);\n\n    // this decides if the edged is two way-i.e undirected or not\n    this.set('isUndirected', options.isUndirected || false);\n\n    // these are the default properties\n    this.set('stroke', '#FFF');\n    this.set('fill', '#FFF');\n    this.set('strokeWidth', 2);\n    this.set('selectable', false);\n    // this.set(\"selectable\", false);\n    this.set('hasControls', false);\n    this.set('perPixelTargetFind', true);\n    // this.set(\"strokeLineJoin\",'round');\n    this.set('hasBorders', false);\n  },\n\n  toObject() {\n    return fabric.util.object.extend(this.callSuper('toObject'), {\n        id: this.get('id'),\n        source : this.get('source'),\n        destination : this.get('destination')\n    });\n  },\n\n  _render(ctx) {\n    this.callSuper('_render', ctx);\n\n    // do not render if width/height are zeros or object is not visible\n    // if (this.width === 0 || this.height === 0 || !this.visible) return;\n    ctx.font = '13px Lato';\n    ctx.fillStyle = '#FFFFFF';\n    ctx.fillText(this.getCost(), 20, 20);\n    ctx.save();\n\n    if(!this.isUndirected){\n      const xDiff = this.x2 - this.x1;\n      const yDiff = this.y2 - this.y1;\n      const angle = Math.atan2(yDiff, xDiff);\n      ctx.rotate(angle);\n      ctx.beginPath();\n      ctx.moveTo(10, 0);\n      ctx.lineTo(-10, 8);\n      ctx.lineTo(-10, -8);\n      ctx.closePath();\n      ctx.fillStyle = this.stroke;\n      ctx.fill();\n    }\n    ctx.restore();\n  },\n\n  getCost(): number {\n    const edgeStart: XY = new XY(this.x1, this.y1);\n    const edgeEnd: XY = new XY(this.x2, this.y2);\n    const edgeLength = XY.getDistanceBetween(edgeStart, edgeEnd);\n    const cost = edgeLength * this.edgeWeight;\n    return Math.floor(cost * 1000) / 1000;\n  }\n\n});\n","import { XY } from './XY';\nimport 'fabric';\ndeclare let fabric;\n\nexport let UIElementNode = fabric.util.createClass(fabric.Circle, {\n\n    type: 'UIElementNode',\n\n    initialize(options) {\n        options || (options = {});\n\n        this.callSuper('initialize', options);\n\n        // this the node id\n        this.set('id', options.id || -1);\n        debugger;\n        // the type of node - start, goal, intermediate, is of type NodeType\n        this.set('nodeType', options.nodeType || NodeType.Intermediate);\n\n        // this will be an array of UIElementEdge objects\n        this.set('asSource', options.asSource || {});\n\n        // this will be an array of UIElementEdge objects\n        this.set('asDestination', options.asDestination || {});\n\n        // these are the default values\n        this.set('radius', options.radius || 50);\n        this.set('originX', options.originX || 'center');\n        this.set('originY', options.originY || 'center');\n\n        switch (this.nodeType) {\n            case NodeType.Goal: {\n                const color = NodeColorMapper.GetGoalNodeColor();\n                this.set('fill', color);\n                break;\n            }\n            case NodeType.Intermediate: {\n                const intermediateNodeColor = NodeColorMapper.GetIntermediateNodeColor();\n                this.set('fill', intermediateNodeColor);\n                break;\n            }\n            case NodeType.Start: {\n                const startNodeColor = NodeColorMapper.GetStartNodeColor();\n                this.set('fill', startNodeColor);\n                break;\n            }\n            default:\n            {\n                const intermediateNodeColor = NodeColorMapper.GetIntermediateNodeColor();\n                this.set('fill', intermediateNodeColor);\n                break;\n            }\n        }\n\n        this.set('shadow', { color: 'rgb(0,0,0)', blur: 3, offsetX: 0, offsetY: 0 });\n        // this.set(\"strokeWidth\",2);\n        // this.set(\"stroke\", \"#FFFFFF\");\n        this.set('lockRotation', true);\n        this.set('lockScalingX', true);\n        this.set('lockScalingY', true);\n        this.set('hasControls', false);\n    },\n\n    toObject() {\n        return fabric.util.object.extend(this.callSuper('toObject'), {\n            id: this.get('id'),\n            nodeName: this.get('nodeName'),\n            nodeType: this.get('nodeType'),\n            asSource: this.get('asSource'),\n            asDestination: this.get('asDestination')\n        });\n    },\n\n    _render(ctx) {\n        this.callSuper('_render', ctx);\n\n        ctx.font = '13px Lato';\n        ctx.fillStyle = '#FFFFFF';\n        ctx.fillText('N-' + this.id, -10, 5);\n        if (this.visitOrder !== undefined) {\n            ctx.fillText('VO: ' + this.visitOrder, -10, 25);\n        }\n        ctx.save();\n        ctx.restore();\n    },\n\n    getEdgeConnectingNode(otherNode): any {\n        /*\n        CASE 1:\n        If the otherNode is the destination of the edge connecting this and other node\n        i.e. configuration is like - this -> other\n        We will surely find as we are iterating over all the asSource edges\n\n        CASE 2:\n        If the otherNode is the source in the relationship\n        i.e. configuration is like - other -> this\n        Will surely find the node as we are iterating over all the asDestination edges\n        */\n\n        // CASE 1\n        const asSourceEdgeIds = Object.keys(this.asSource);\n        for (const edgeId of asSourceEdgeIds) {\n            const edge = this.asSource[edgeId];\n            const node = edge.destination;\n            if (node === otherNode) {\n                return edge;\n            }\n        }\n\n        // CASE 2\n        const asDestinationEdgeIds = Object.keys(this.asDestination);\n        for (const edgeId of asDestinationEdgeIds) {\n            const edge = this.asDestination[edgeId];\n            const node = edge.source;\n            if (node === otherNode) {\n                return edge;\n            }\n        }\n\n        return null;\n    },\n\n    getDistanceTo(otherNode: any): number {\n        const thisPos = new XY(this.left, this.top);\n        const otherPos = new XY(otherNode.left, otherNode.top);\n        return thisPos.distanceTo(otherPos);\n    },\n\n    getAllNeighbouringNodes(): any {\n        /*\n        How are neighbours collected?\n        When an edge is directed and the current node is the source, then the destination can be reached\n        hence is a valid neighbour.\n        When an edge is undirected and the current node is the source, then the destination can \n        still be reached hence is a valid neighbour.\n        When an edge is directed and the current node is the destinatio, then the source cannot be reached\n        hence the source is not a valid neighbour.\n        When an edge is undirected and the current node is the destination, then the source can be \n        reached, hence the source is a valid neighbour.\n        */\n\n        let neighbours = []\n\n        // Iterate over all the edges in which the node is a source\n        const asSourceEdgeIds = Object.keys(this.asSource);\n        for (const edgeId of asSourceEdgeIds) {\n            const edge = this.asSource[edgeId];\n            const node = edge.destination;\n            if(node.id != this.id){\n                neighbours.push(node);\n            }\n        }\n\n        const asDestinationEdgeIds = Object.keys(this.asDestination);\n        for (const edgeId of asDestinationEdgeIds) {\n            const edge = this.asDestination[edgeId];\n            if(edge.isUndirected){\n                const node = edge.source;\n                if(node.id != this.id){\n                    neighbours.push(node);\n                }\n            }\n        }\n\n        return neighbours;\n    },\n\n    getAllNeighbouringNodesWithCost(): any{\n        let neighbours = []\n        let costs = []\n\n        // Iterate over all the edges in which the node is a source\n        const asSourceEdgeIds = Object.keys(this.asSource);\n        for (const edgeId of asSourceEdgeIds) {\n            const edge = this.asSource[edgeId];\n            const node = edge.destination;\n            neighbours.push(node);\n            costs.push(edge.getCost());\n        }\n\n        const asDestinationEdgeIds = Object.keys(this.asDestination);\n        for (const edgeId of asDestinationEdgeIds) {\n            const edge = this.asDestination[edgeId];\n            if(edge.isUndirected){\n                const node = edge.source;\n                neighbours.push(node);\n                costs.push(edge.getCost());\n            }\n        }\n\n        return {'neighbours': neighbours, 'costs': costs};\n    },\n\n    getAllNeighbourData(): any{\n        let neighbours = []\n        let costs = []\n        let edges = []\n\n        // Iterate over all the edges in which the node is a source\n        const asSourceEdgeIds = Object.keys(this.asSource);\n        for (const edgeId of asSourceEdgeIds) {\n            const edge = this.asSource[edgeId];\n            const node = edge.destination;\n            neighbours.push(node);\n            costs.push(edge.getCost());\n            edges.push(edge);\n        }\n\n        const asDestinationEdgeIds = Object.keys(this.asDestination);\n        for (const edgeId of asDestinationEdgeIds) {\n            const edge = this.asDestination[edgeId];\n            if(edge.isUndirected){\n                const node = edge.source;\n                neighbours.push(node);\n                costs.push(edge.getCost());\n                edges.push(edge);\n            }\n        }\n\n        return {'neighbours': neighbours, 'costs': costs, 'edges': edges};\n    }\n});\n\nexport enum NodeType {\n    Start= 1,\n    Intermediate,\n    Goal\n}\n\nexport class NodeColorMapper {\n    private static COLOR_MAP = {\n        Start : '#0849A2',\n        Goal : '#08A229',\n        Intermediate : '#FF5733'\n    };\n\n    public static GetIntermediateNodeColor(): string {\n        return this.COLOR_MAP.Intermediate;\n    }\n\n    public static GetGoalNodeColor(): string {\n        return this.COLOR_MAP.Goal;\n    }\n\n    public static GetStartNodeColor(): string {\n        return this.COLOR_MAP.Start;\n    }\n\n}\n","import { NodeType } from './UIElementNode';\nimport { PriorityQueue } from './PriorityQueue';\nimport { IQueue } from './Queue';\nimport { NodeStateInSearch } from './NodeStateInSearch';\nimport { SimulatorComponent } from 'src/app/simulator/simulator.component';\nimport { Solution } from './Solution';\nimport { NodeStateInSearchColorMapper } from './NodeStateInSearchColorMapper';\n\nexport class UniformCostSolver {\n    static Prepare(simulatorInstance: SimulatorComponent) {\n\n        Object.keys(simulatorInstance.nodes).forEach(nodeid => {\n            const node = simulatorInstance.nodes[nodeid];\n\n            // initialize the current cost to max(therotically, infinity)\n            node.cost = Number.MAX_VALUE;\n\n            // initialize the parent to null\n            node.parent = null;\n\n            // Mark if a node is visited\n            node.stateInSearch = NodeStateInSearch.NOT_VISITED;\n\n            node.visitOrder = '';\n        });\n\n    }\n\n    static Solve(simulatorComponent: SimulatorComponent): Solution {\n        UniformCostSolver.Prepare(simulatorComponent);\n\n        let visitOrder = 1;\n\n        simulatorComponent.startNode.cost = 0; // the cost of the start node to itself will be zero\n        simulatorComponent.startNode.stateInSearch = NodeStateInSearch.CURRENT; // mark the startNode as current-i.e. it is being visited right now, and\n        // that some or all of its children are yet to be expanded\n        simulatorComponent.startNode.visitOrder = visitOrder;\n\n        // For visual representation set the color as well\n        simulatorComponent.startNode.set({\n            stroke: NodeStateInSearchColorMapper.GetColorForCurrentNode(),\n            dirty: true\n        });\n\n        let queue: PriorityQueue<any>;\n\n        const compareNodes = function(nodeA, nodeB) {\n            return nodeA.cost - nodeB.cost;\n        };\n\n        // use a priority queue for uniform cost search\n        queue = new PriorityQueue({ comparator: compareNodes });\n\n        queue.enqueue(simulatorComponent.startNode);\n\n        while (!queue.isEmpty()) {\n            const currentNode = queue.dequeue();\n            const nodeType: NodeType = currentNode.nodeType;\n            if (nodeType === NodeType.Goal) {\n                // create a solution object and tranverse through all the parents of the GOAL NODE\n                const sol: Solution = new Solution(currentNode.cost);\n                let tempNode = currentNode;\n                while (tempNode != null) {\n                    sol.addNodeToPath(tempNode);\n                    // find the edge connecting tempNode and tempNode.parent\n                    if (tempNode.parent != null) {\n                        const edgeConnectingParent = tempNode.getEdgeConnectingNode(tempNode.parent);\n                        sol.addEdgeToPath(edgeConnectingParent);\n                    }\n\n                    tempNode = tempNode.parent;\n                }\n                return sol;\n            }\n\n            // Get all the neighbouring nodes\n            let neighbourData = currentNode.getAllNeighbouringNodesWithCost();\n            let neighbours = neighbourData['neighbours'];\n            let costs = neighbourData['costs'];\n            //const edges = currentNode.asSource; // Get all the edges in which the node is a source\n            //const edgeIds = Object.keys(edges);\n            for (var i = 0; i < neighbours.length; i++) {\n                //const edge = edges[edgeId];\n                const nextNode = neighbours[i];\n                const cost = costs[i];\n\n                if (nextNode.stateInSearch === NodeStateInSearch.NOT_VISITED) {\n                    // the nextNode is being seen for the 1st time\n                    nextNode.cost = currentNode.cost + cost;\n\n                    // set the parent of the nextNode\n                    nextNode.parent = currentNode;\n\n                    // set the state of the nextNode to seen or current\n                    nextNode.stateInSearch = NodeStateInSearch.CURRENT;\n\n                    nextNode.set({\n                        stroke: NodeStateInSearchColorMapper.GetColorForCurrentNode(),\n                        dirty: true\n                    });\n\n                    // enque the node for expansion\n                    queue.enqueue(nextNode);\n                } else if (nextNode.stateInSearch === NodeStateInSearch.CURRENT) {\n                    // the nextNode has been seen before\n\n                    const newCost = currentNode.cost + cost;\n\n                    if (newCost < nextNode.cost) {\n                        // a better way to reach newNode has been seen\n                        nextNode.cost = newCost;\n\n                        nextNode.parent = currentNode;\n\n                        queue.heapify(); // refresh the queue order\n                    }\n\n                } // else if nextNode.stateInSearch === NodeStateInSearch.VISITED, it has been explored completely\n            }\n\n            // after all the nodes of the current node are expanded, we set the current state to visited\n            currentNode.stateInSearch = NodeStateInSearch.VISITED;\n            currentNode.set({\n                stroke: NodeStateInSearchColorMapper.GetColorForVisitedNode(),\n                dirty: true\n            });\n            currentNode.visitOrder = visitOrder++;\n        }\n\n        // if the queue is empty and a solution is not found till now, then there is no\n        // solution to the problem\n        return new Solution(Number.MAX_VALUE);\n    }\n\n}","import { XY } from './XY';\n\nexport class Utility{\n\n    public static GenerateRandomPointInBox(min : XY, max: XY) : XY{\n        var x1 : number = Utility.GenerateRandomNumberBetween(min.X, max.X);\n        var y1 : number = Utility.GenerateRandomNumberBetween(min.Y, max.Y);\n        return new XY(x1, y1);\n    }\n\n    public static GenerateRandomNumberBetween(lowerBound : number, upperBound: number) : number {\n        var range : number = Math.abs(upperBound - lowerBound);\n        return Math.floor(Math.random() * range) + lowerBound;\n    }\n\n    public static Sleep(miliseconds) {\n        var currentTime = new Date().getTime();\n\n        while (currentTime + miliseconds >= new Date().getTime()) {\n        }\n     }\n\n}","export class XY {\n    public static BasisX = new XY(1, 0);\n    public static BasisY = new XY(0, 1);\n    public static BasisXY = new XY(1, 1);\n\n    public X: number;\n    public Y: number;\n\n    static getDistanceBetween(edgeStart: XY, edgeEnd: XY): number {\n        const vec: XY = edgeStart.subtract(edgeEnd);\n        return vec.getLength();\n    }\n\n    constructor(X: number, Y: number) {\n        this.X = X;\n        this.Y = Y;\n    }\n\n    public add(other: XY) {\n        const newX = this.X + other.X;\n        const newY = this.Y + other.Y;\n        return new XY(newX, newY);\n    }\n\n    public subtract(other) {\n        const newX = this.X - other.X;\n        const newY = this.Y - other.Y;\n        return new XY(newX, newY);\n    }\n\n    public multiply(scalar) {\n        const newX = this.X * scalar;\n        const newY = this.Y * scalar;\n        return new XY(newX, newY);\n    }\n\n    public divide(scalar) {\n        const newX = this.X / scalar;\n        const newY = this.Y / scalar;\n        return new XY(newX, newY);\n    }\n\n    public toString() {\n        return 'X: ' + this.X + ', Y: ' + this.Y;\n    }\n\n    public getPolarAngleInDegree() {\n        const angleInRadian = Math.atan2(this.Y, this.X);\n        let angleInDegree = angleInRadian * (180 / Math.PI);\n\n        if (angleInDegree <= 0) { // is negative or zero.\n            if (Math.abs(angleInDegree) <= 5) { // in this case the angle can be in the range -5 to +5. We set it to 0, this test case captures when the vector angle is very \n                // close to 0. We need to set it to 0.\n                angleInDegree = 0;\n            } else {\n                angleInDegree = 360 + angleInDegree;\n            }\n        }\n        return angleInDegree;\n    }\n\n    public dotProduct(other: XY) {\n        return this.X * other.X + this.Y + other.Y;\n    }\n\n    public isVectical() {\n        const polarAngle = this.getPolarAngleInDegree();\n        return (\n                (Math.abs(polarAngle - 90) <= 3) ||\n                (Math.abs(polarAngle - 270) <= 3)\n            );\n    }\n\n    public crossProduct(other) {\n        // cross product: we have two vectors, this and other. We need to find the cross product of this and other\n        // it will be equal to\n        // this.x * other.y - this.y * other.x\n        return this.X * other.Y - this.Y * other.X; \n    }\n\n    public getLength() {\n        return Math.sqrt(\n            Math.pow(this.X, 2) + Math.pow(this.Y, 2)\n        );\n    }\n\n    public getUnitVector() {\n        const length = this.getLength();\n        const unitVector = this.divide(length);\n        return unitVector;\n    }\n\n    distanceTo(other: XY): number {\n        const vector = this.subtract(other);\n        return vector.getLength();\n    }\n\n}\n","import { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { SimulatorComponent } from './simulator/simulator.component';\n\nconst routes: Routes = [\n  {\n    path: '',\n    component: SimulatorComponent\n  }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n","module.exports = \"\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJzcmMvYXBwL2FwcC5jb21wb25lbnQuY3NzIn0= */\"","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'AISearchSimulator';\n}\n","import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { SimulatorComponent, HelpDialogComponent } from './simulator/simulator.component';\nimport { MaterialModule } from './material/material.module';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\nimport { FormsModule } from '@angular/forms';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    SimulatorComponent,\n    HelpDialogComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    MaterialModule,\n    BrowserAnimationsModule,\n    FormsModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent],\n  entryComponents: [\n    HelpDialogComponent,\n  ],\n})\nexport class AppModule { }\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { MatButtonModule, MatIconModule, MatTooltipModule, MatSelectModule,\n         MatInputModule, MatFormFieldModule, MatSnackBarModule,\n         MatDialogModule } from '@angular/material';\n\nconst MaterialComponents = [\n  MatButtonModule,\n  MatIconModule,\n  MatTooltipModule,\n  MatSelectModule,\n  MatInputModule,\n  MatFormFieldModule,\n  MatSnackBarModule,\n  MatDialogModule\n];\n@NgModule({\n  declarations: [],\n  imports: [\n    CommonModule\n  ],\n  exports: [\n    MaterialComponents\n  ]\n})\nexport class MaterialModule { }\n","module.exports = \":host{\\n    width: 100%;\\n    height: 100%;\\n}\\n\\n.contentMain{\\n    /* border: 1px dashed pink; */\\n    width: 100%;\\n    height: 100%;\\n    overflow: hidden;\\n}\\n\\n.canvasWrapper{\\n    /* background: rebeccapurple; */\\n    /* border: 1px solid rebeccapurple; */\\n    width: 100%;\\n    height: 100%;\\n}\\n\\n.canvasElement{\\n    /* background: greenyellow; */\\n    /* border: 2px dotted goldenrod; */\\n    width: 100%;\\n    height: 100%;\\n}\\n\\n.floatingMainMenu{\\n    right: 25px;\\n    top: 0;\\n    /* margin-top: 10px; */\\n    padding: 10px;\\n    box-shadow: 0 2px 6px 0px  rgba(0,0,0,0.2);\\n    background: white;\\n    /* width: 20%; */\\n    position: absolute;\\n    z-index: 10;\\n    border-bottom-left-radius: 3%;\\n    border-bottom-right-radius: 3%;\\n    max-height: 70vh;\\n    /* border: 2px solid darkblue; */\\n    /* overflow-y: scroll; */\\n    max-width: 180px;\\n}\\n\\n.uiUtilityMenu{\\n    left: 0;\\n    top: 0;\\n    position: absolute;\\n    /* margin-top: 10px;\\n    margin-left: 5px; */\\n}\\n\\n.uiUtilityMenu .optionsButton{\\n    color: lightgrey;\\n}\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAvc2ltdWxhdG9yL3NpbXVsYXRvci5jb21wb25lbnQuY3NzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0lBQ0ksV0FBVztJQUNYLFlBQVk7QUFDaEI7O0FBRUE7SUFDSSw2QkFBNkI7SUFDN0IsV0FBVztJQUNYLFlBQVk7SUFDWixnQkFBZ0I7QUFDcEI7O0FBRUE7SUFDSSwrQkFBK0I7SUFDL0IscUNBQXFDO0lBQ3JDLFdBQVc7SUFDWCxZQUFZO0FBQ2hCOztBQUVBO0lBQ0ksNkJBQTZCO0lBQzdCLGtDQUFrQztJQUNsQyxXQUFXO0lBQ1gsWUFBWTtBQUNoQjs7QUFFQTtJQUNJLFdBQVc7SUFDWCxNQUFNO0lBQ04sc0JBQXNCO0lBQ3RCLGFBQWE7SUFDYiwwQ0FBMEM7SUFDMUMsaUJBQWlCO0lBQ2pCLGdCQUFnQjtJQUNoQixrQkFBa0I7SUFDbEIsV0FBVztJQUNYLDZCQUE2QjtJQUM3Qiw4QkFBOEI7SUFDOUIsZ0JBQWdCO0lBQ2hCLGdDQUFnQztJQUNoQyx3QkFBd0I7SUFDeEIsZ0JBQWdCO0FBQ3BCOztBQUVBO0lBQ0ksT0FBTztJQUNQLE1BQU07SUFDTixrQkFBa0I7SUFDbEI7dUJBQ21CO0FBQ3ZCOztBQUVBO0lBQ0ksZ0JBQWdCO0FBQ3BCIiwiZmlsZSI6InNyYy9hcHAvc2ltdWxhdG9yL3NpbXVsYXRvci5jb21wb25lbnQuY3NzIiwic291cmNlc0NvbnRlbnQiOlsiOmhvc3R7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xufVxuXG4uY29udGVudE1haW57XG4gICAgLyogYm9yZGVyOiAxcHggZGFzaGVkIHBpbms7ICovXG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbi5jYW52YXNXcmFwcGVye1xuICAgIC8qIGJhY2tncm91bmQ6IHJlYmVjY2FwdXJwbGU7ICovXG4gICAgLyogYm9yZGVyOiAxcHggc29saWQgcmViZWNjYXB1cnBsZTsgKi9cbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG59XG5cbi5jYW52YXNFbGVtZW50e1xuICAgIC8qIGJhY2tncm91bmQ6IGdyZWVueWVsbG93OyAqL1xuICAgIC8qIGJvcmRlcjogMnB4IGRvdHRlZCBnb2xkZW5yb2Q7ICovXG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xufVxuXG4uZmxvYXRpbmdNYWluTWVudXtcbiAgICByaWdodDogMjVweDtcbiAgICB0b3A6IDA7XG4gICAgLyogbWFyZ2luLXRvcDogMTBweDsgKi9cbiAgICBwYWRkaW5nOiAxMHB4O1xuICAgIGJveC1zaGFkb3c6IDAgMnB4IDZweCAwcHggIHJnYmEoMCwwLDAsMC4yKTtcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICAvKiB3aWR0aDogMjAlOyAqL1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB6LWluZGV4OiAxMDtcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAzJTtcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMyU7XG4gICAgbWF4LWhlaWdodDogNzB2aDtcbiAgICAvKiBib3JkZXI6IDJweCBzb2xpZCBkYXJrYmx1ZTsgKi9cbiAgICAvKiBvdmVyZmxvdy15OiBzY3JvbGw7ICovXG4gICAgbWF4LXdpZHRoOiAxODBweDtcbn1cblxuLnVpVXRpbGl0eU1lbnV7XG4gICAgbGVmdDogMDtcbiAgICB0b3A6IDA7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIC8qIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgbWFyZ2luLWxlZnQ6IDVweDsgKi9cbn1cblxuLnVpVXRpbGl0eU1lbnUgLm9wdGlvbnNCdXR0b257XG4gICAgY29sb3I6IGxpZ2h0Z3JleTtcbn0iXX0= */\"","import { Component, OnInit, Inject, HostListener } from '@angular/core';\nimport { XY } from '../../Utils/XY';\nimport { UIElementNode, NodeType, NodeColorMapper } from '../../Utils/UIElementNode';\nimport { UIElementEdge } from '../../Utils/UIElementEdge';\nimport { Utility } from 'src/Utils/Utility';\nimport { IdGenerator } from 'src/Utils/IdGenerator';\nimport { SearchSolvers } from 'src/Utils/SearchSolvers';\nimport { MatSnackBar } from '@angular/material';\nimport { MatDialog} from '@angular/material/dialog';\n\nimport 'fabric';\nimport { GeneralAlgorithms } from 'src/Utils/GeneralAlgorithms';\nimport { TopologicalSorting } from 'src/Utils/TopologicalSorting';\nimport { GraphBridges } from 'src/Utils/GraphBridges';\nimport { ConvexHull } from 'src/Utils/ConvexHull';\ndeclare let fabric;\n\nexport enum CanvasState {\n  Normal = 1,\n  DrawingEdge\n}\n\n@Component({\n  selector: 'app-simulator',\n  templateUrl: './simulator.component.html',\n  styleUrls: ['./simulator.component.css']\n})\nexport class SimulatorComponent implements OnInit {\n  public canvas;\n  public canvasElementWidth: number;\n  public canvasElementHeight: number;\n  public zoom: number;\n  public algorithms: string[] = ['Breadth first search', 'Uniform cost search', 'Depth first search', 'Depth first (Optimal)', 'Best-Fit (Greedy)', 'Best-Fit (A*)', 'Check Bipartiteness', 'Topological Ordering', 'Find Bridges(Undirected graph)', 'Convex Hull'];\n  public selectedAlgorithm: string;\n  public nodes: any = {};\n  public edges: any = {};\n  public isLinkingEnabled = false;\n  public isLinkingBidirectional = false;\n  public isDragButtonEnabled = false;\n  public activeObject: any = null;\n  public tempEdge: any = null;\n  public idGenerator: IdGenerator = new IdGenerator(Number.MAX_SAFE_INTEGER);\n  public startNode: any = null;\n  public goalNodes: any = {};\n  public numbers: number[] = [];\n\n  constructor(private snackBar: MatSnackBar, public dialog: MatDialog) { }\n\n  ngOnInit() {\n  }\n\n  clearAll() {\n    this.deleteAllNodes();\n    this.deleteAllEdges();\n    this.activeObject = null;\n    this.startNode = null;\n    this.goalNodes = {};\n    this.numbers = [];\n    this.idGenerator = new IdGenerator(Number.MAX_SAFE_INTEGER);\n  }\n\n  deleteAllNodes(){\n    let nodeIds = Object.keys(this.nodes);\n    for(var i = 0; i < nodeIds.length; i++){\n      this.canvas.remove(this.nodes[nodeIds[i]]);\n    }\n    this.nodes = {}\n  }\n\n  deleteAllEdges() {\n    let edgeIds = Object.keys(this.edges);\n    for(var i = 0; i < edgeIds.length; i++){\n      this.canvas.remove(this.edges[edgeIds[i]]);\n    }\n    this.edges = {}\n  }\n\n  ngAfterViewInit() {\n    const canvasContainerElement = document.getElementById('contentMain');\n    this.canvasElementWidth = canvasContainerElement.offsetWidth;\n    this.canvasElementHeight = canvasContainerElement.offsetHeight;\n\n    this.canvas = new fabric.Canvas('canvasElement', {\n      backgroundColor: '#566573',\n      width: this.canvasElementWidth,\n      height: this.canvasElementHeight,\n      preserveObjectStacking: true\n    });\n\n    // initialize the drag to false\n    this.canvas.isDragging = false;\n\n    this.canvas.on('mouse:wheel', (opt) => {\n      console.log('Wheel');\n      const viewportTransform = this.canvas.viewportTransform;\n      console.log('Viewport trnasform: ' + viewportTransform);\n      const delta = opt.e.deltaY;\n      let zoom = this.canvas.getZoom();\n      this.zoom = Math.round(zoom * 5) / 5;\n      console.log('Zoom: ' + zoom);\n      zoom = zoom - delta / 2000;\n      if (zoom > 20) { zoom = 20; }\n      if (zoom < 0.01) { zoom = 0.01; }\n      // fabricCanvas.setZoom(zoom);\n      this.canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom); // point, zoom amount\n      opt.e.preventDefault();\n      opt.e.stopPropagation();\n    });\n\n    this.canvas.on('mouse:up', (opt) => {\n      // debugger;\n      this.canvas.isDragging = false;\n      this.canvas.selection = true;\n      this.canvas.mouseDown = false;\n\n      debugger;\n      // Get the old selection\n      const oldSelection = this.activeObject;\n      console.log(oldSelection);\n\n      // Get the current selection\n      this.activeObject = this.canvas.getActiveObject();\n      console.log(this.activeObject);\n\n      if (this.isLinkingEnabled || this.isLinkingBidirectional) {\n\n        if (oldSelection != null && this.activeObject != null) {\n\n          if (this.isEdge(oldSelection) || this.isEdge(this.activeObject)) {\n            // if either of the objects are Edges, then we do not proceed\n            this.canvas.remove(this.tempEdge);\n            return;\n          }\n\n          if (oldSelection !== this.activeObject) {\n            console.log('Different selection');\n\n            // remove the temporary edge\n            this.canvas.remove(this.tempEdge);\n            const rid = this.idGenerator.generateNew();\n\n            // draw a line from the current selection to the new selection\n            const edge = new UIElementEdge([oldSelection.left, oldSelection.top, this.activeObject.left, this.activeObject.top],\n              {\n                id: rid,\n                source: oldSelection,\n                destination: this.activeObject,\n                isUndirected: this.isLinkingBidirectional\n              }\n            );\n\n            this.registerNodeInEdge(edge, oldSelection, this.activeObject, this.isLinkingBidirectional);\n            // this.registerNodeInEdge(edge, oldSelection, this.activeObject);\n\n          } else {\n            console.log('Same selection');\n            this.canvas.remove(this.tempEdge);\n          }\n        } else if (oldSelection != null && this.activeObject == null) {\n          console.log('An edge was selected before, but nothing has been selected in this click');\n          // remove the temp edge\n          this.canvas.remove(this.tempEdge);\n        }\n      }\n\n\n    });\n\n    this.canvas.on('mouse:down', (opt) => {\n      // debugger\n      this.canvas.mouseDown = true;\n      const evt = opt.e;\n      if (evt.altKey === true || this.isDragButtonEnabled) {\n        console.log('Alt and down');\n        this.canvas.isDragging = true;\n        this.canvas.selection = false;\n        this.canvas.lastPosX = evt.clientX;\n        this.canvas.lastPosY = evt.clientY;\n      }\n    });\n\n    this.canvas.on('mouse:move', (opt) => {\n      // debugger;\n      const point = new XY(opt.e.layerX, opt.e.layerY);\n      const viewportTransform = this.canvas.viewportTransform;\n      // for (var i = 0; i < viewportTransform.length; i++) {\n      //   viewportTransform[i] = Math.round(viewportTransform[i] * 100) / 100;\n      // }\n      const xDelta = this.canvas.viewportTransform[4] * -1;\n      const yDelta = this.canvas.viewportTransform[5] * -1;\n\n      point.X = (1 / viewportTransform[0]) * (point.X + xDelta);\n      point.Y = (1 / viewportTransform[3]) * (point.Y + yDelta);\n\n      if (this.canvas.isDragging) {\n        const e = opt.e;\n        this.canvas.viewportTransform[4] += e.clientX - this.canvas.lastPosX;\n        this.canvas.viewportTransform[5] += e.clientY - this.canvas.lastPosY;\n        this.canvas.requestRenderAll();\n        this.canvas.lastPosX = e.clientX;\n        this.canvas.lastPosY = e.clientY;\n      }\n\n      // **START** draw a temporary arrow (rep. an edge) for visual feedback******//\n      if ((this.isLinkingEnabled || this.isLinkingBidirectional )&& this.activeObject != null) {\n\n        // draw an edge from the selected item to the current mouse location\n\n        if (this.tempEdge != null) {\n          this.canvas.remove(this.tempEdge);\n        }\n\n        this.tempEdge =\n          new UIElementEdge(\n            [this.activeObject.left, this.activeObject.top, point.X, point.Y], {\n              id: -1,\n              fill: '#959494',\n              stroke: '#959494',\n              strokeWidth: 2,\n              selectable: false,\n              isUndirected: this.isLinkingBidirectional\n            }\n          );\n\n        this.canvas.add(this.tempEdge);\n        this.canvas.sendToBack(this.tempEdge);\n        this.canvas.requestRenderAll();\n      }\n      // **END** draw a temporary arrow for visual feedback ends here ******//\n\n\n      // **START**if the node is being moved, move the associated edges with a node***//\n      const currentSelection = this.canvas.getActiveObject();\n      if (this.isNode(currentSelection)) {\n        // debugger;\n        // iterate over all the asSource edges\n        let edge;\n\n        // iterate over all the asSource edges\n        this.objectKeys(currentSelection.asSource).forEach(edgeKey => {\n          edge = currentSelection.asSource[edgeKey];\n          // When a user draws an arrow, even though the edge is undirected, we \n          // store the source and destination. Which will help us set the coordinates\n          // of the edge correctly depending on the node(source/destination) being moved\n          if(edge.source.id == currentSelection.id){\n            edge.set({\n              x1: currentSelection.left,\n              y1: currentSelection.top,\n              dirty: true\n            });\n          }\n        });\n\n        // iterate over all the asDestination edges\n        this.objectKeys(currentSelection.asDestination).forEach(edgeKey => {\n          edge = currentSelection.asDestination[edgeKey];\n          if(edge.destination.id == currentSelection.id){\n            edge.set({\n              x2: currentSelection.left,\n              y2: currentSelection.top,\n              dirty: true\n            });\n          }\n        });\n\n        // render dirty members on the canavs\n        this.canvas.requestRenderAll();\n\n      }\n      // **END**if the node is being moved, move the associated edges with a node, if\n\n    });\n\n    this.canvas.on('mouse:dblclick', (opt) => {\n      const selectedElement = this.canvas.getActiveObject();\n      console.log('Double click');\n      if (selectedElement != null) {\n        return;\n      }\n\n      // create a new node with default values at the location of double click\n      const point = new XY(opt.e.layerX, opt.e.layerY);\n      const viewportTransform = this.canvas.viewportTransform;\n      const xDelta = this.canvas.viewportTransform[4] * -1;\n      const yDelta = this.canvas.viewportTransform[5] * -1;\n\n      point.X = (1 / viewportTransform[0]) * (point.X + xDelta);\n      point.Y = (1 / viewportTransform[3]) * (point.Y + yDelta);\n\n      this.createNewNodeAt(point);\n    });\n\n    document.addEventListener('keydown', (event) => {\n      console.log(event.key);\n      if (event.key === 'Delete') {\n        // Implement code to delete an edge or a node\n      }\n\n      if (event.key === 'Escape' && (this.isLinkingEnabled || this.isLinkingBidirectional)) {\n        // if esacpe has been clicked and we are in the linking state\n        // deactivate an object that may have been active\n        this.canvas.discardActiveObject();\n        this.canvas.requestRenderAll();\n        this.activeObject = null;\n        // remove the temp edge if there exists one\n        if (this.tempEdge != null) {\n          this.canvas.remove(this.tempEdge);\n        }\n      }\n\n    });\n\n  }\n\n  @HostListener('window:resize', ['$event'])\n  onResize(event) {\n    console.log(event.target.innerWidth);\n    this.canvasElementWidth = event.target.innerWidth;\n    console.log(event.target.innerHeight);\n    this.canvasElementHeight = event.target.innerHeight;\n    this.canvas.set({\n      width : this.canvasElementWidth,\n      height : this.canvasElementHeight\n    });\n    this.groupFocus();\n  }\n\n  runSimulator() {\n\n    switch (this.selectedAlgorithm) {\n      case this.algorithms[0]: {\n        // breadth first\n\n        const result = SearchSolvers.ValidateGraph(this);\n        if (!result.isValid) {\n          this.snackBar.open(result.message, 'Got it!');\n          return;\n        }\n\n        const res = SearchSolvers.SolveByBreadthFirst(this);\n        this.snackBar.open(res.message, 'Okay!');\n        return;\n      }\n      case this.algorithms[1]: {\n        // Uniform cost search\n\n        const result = SearchSolvers.ValidateGraph(this);\n        if (!result.isValid) {\n          this.snackBar.open(result.message, 'Got it!');\n          return;\n        }\n\n        const res = SearchSolvers.SolveByUniformCostSearch(this);\n        this.snackBar.open(res.message, 'Okay!');\n        return;\n      }\n      case this.algorithms[2]: {\n        // depth first\n\n        const result = SearchSolvers.ValidateGraph(this);\n        if (!result.isValid) {\n          this.snackBar.open(result.message, 'Got it!');\n          return;\n        }\n\n        const res = SearchSolvers.SolveByDepthFirst(this, false);\n        this.snackBar.open(res.message, 'Okay!');\n        return;\n      }\n      case this.algorithms[3]: {\n        // depth-first(optimal)\n\n        const result = SearchSolvers.ValidateGraph(this);\n        if (!result.isValid) {\n          this.snackBar.open(result.message, 'Got it!');\n          return;\n        }\n\n        const res = SearchSolvers.SolveByDepthFirst(this, true);\n        this.snackBar.open(res.message, 'Okay!');\n        return;\n      }\n      case this.algorithms[4]: {\n        // greedy best fit\n\n        const result = SearchSolvers.ValidateGraph(this);\n        if (!result.isValid) {\n          this.snackBar.open(result.message, 'Got it!');\n          return;\n        }\n        const res = SearchSolvers.SolveByBestFit(this, false);\n        this.snackBar.open(res.message, 'Okay!');\n        return;\n      }\n      case this.algorithms[5]: {\n        // A* search\n        const result = SearchSolvers.ValidateGraph(this);\n        if (!result.isValid) {\n          this.snackBar.open(result.message, 'Got it!');\n          return;\n        }\n        const res = SearchSolvers.SolveByBestFit(this, true);\n        this.snackBar.open(res.message, 'Okay!');\n        return;\n      }\n      case this.algorithms[6]:{\n        // Check if bipartite\n        const res = GeneralAlgorithms.CheckIfBipartite(this);\n        this.snackBar.open(res.message, \"Okay\");\n        return;\n      }\n      case this.algorithms[7]: {\n        // Topological ordering\n        const res = TopologicalSorting.Sort(this);\n        this.snackBar.open(res.message, \"Okay!\");\n        return;\n      }\n      case this.algorithms[8]:{\n        // Find Bridges(Undirected graph)\n        const res = GraphBridges.Identify(this);\n        this.snackBar.open(res.message, \"Okay!\");\n        return;\n      }\n      case this.algorithms[9]:{\n        // convex hull\n        const res = ConvexHull.Find(this);\n        this.snackBar.open(res.message, \"Okay\");\n        return;\n      }\n    }\n  }\n\n  registerNodeInEdge(edge: any, oldSelection: any, currentSelection: any, \n    isLinkingBidirectional: boolean) {\n    //isLinkingBidirectional: boolean\n    \n    this.canvas.add(edge);\n    this.edges[edge.id] = edge;\n    // add the edge in the asSource and asDestination members of the source and destination node\n    oldSelection.asSource[edge.id] = edge;\n    currentSelection.asDestination[edge.id] = edge;\n    \n    if(isLinkingBidirectional){\n      currentSelection.asSource[edge.id] = edge;\n      oldSelection.asDestination[edge.id] = edge;\n    }\n    this.canvas.sendToBack(edge);\n  }\n\n  isEdge(obj: any): boolean {\n    if (obj == null) {\n      return false;\n    }\n\n    return obj.type === 'UIElementEdge';\n\n  }\n\n  objectKeys(object) {\n    return Object.keys(object);\n  }\n\n  AddNode() {\n    // Get the center of the screen (in screen coordinates)\n    const screenCenter: XY = this.getScreenCenter();\n    const screenCenterInCanvasSystem: XY = this.transformScreenToCanvas(screenCenter);\n    // debugger;\n    const boxMin = screenCenterInCanvasSystem.add(XY.BasisXY.multiply(-1 * 100));\n    const boxMax = screenCenterInCanvasSystem.add(XY.BasisXY.multiply(100));\n\n    // generate a random point within a box in the centre of the screen\n    const newNodePos: XY = Utility.GenerateRandomPointInBox(boxMin, boxMax);\n    this.createNewNodeAt(newNodePos);\n  }\n\n  AddNodeInBox(boxMin, boxMax){\n    // generate a random point within a box in the centre of the screen\n    const newNodePos: XY = Utility.GenerateRandomPointInBox(boxMin, boxMax);\n    this.createNewNodeAt(newNodePos);\n  }\n\n  AddRandomNodes(){\n\n    let nodeCount = Utility.GenerateRandomNumberBetween(3, 8);\n\n    // Get the center of the screen (in screen coordinates)\n    const screenCenter: XY = this.getScreenCenter();\n    const screenCenterInCanvasSystem: XY = this.transformScreenToCanvas(screenCenter);\n    // debugger;\n    const boxMin = screenCenterInCanvasSystem.add(XY.BasisXY.multiply(-1 * 250));\n    const boxMax = screenCenterInCanvasSystem.add(XY.BasisXY.multiply(250));\n\n    for(var i = 1; i <= nodeCount; i++){\n      this.AddNodeInBox(boxMin, boxMax);\n    }\n\n  }\n\n  transformScreenToCanvas(pointInScreenSystem: XY): XY {\n    let pointInCanvasSystem: XY;\n\n    // get transform from screen system to canvas system\n    const viewportTransform = this.canvas.viewportTransform;\n    const xDelta = this.canvas.viewportTransform[4] * -1;\n    const yDelta = this.canvas.viewportTransform[5] * -1;\n\n    const X = (1 / viewportTransform[0]) * (pointInScreenSystem.X + xDelta);\n    const Y = (1 / viewportTransform[3]) * (pointInScreenSystem.Y + yDelta);\n\n    pointInCanvasSystem = new XY(X, Y);\n\n    return pointInCanvasSystem;\n  }\n\n  getScreenCenter(): XY {\n    return new XY(this.canvasElementWidth / 2, this.canvasElementHeight / 2);\n  }\n\n  createNewNodeAt(point: XY) {\n    const id = Object.keys(this.nodes).length + 1;\n    const node = new UIElementNode({\n      id,\n      left: point.X,\n      top: point.Y\n    });\n    this.registerNodeInGraph(node);\n    this.canvas.setActiveObject(node);\n    this.activeObject = node;\n    this.canvas.requestRenderAll();\n  }\n\n  registerNodeInGraph(node: any) {\n    this.canvas.add(node);\n    this.nodes[node.id] = node;\n  }\n\n  toggleEdgeState() {\n    this.isLinkingEnabled = !this.isLinkingEnabled;\n    this.isLinkingBidirectional = false;\n    // this.isLinkingEnabled = !this.isLinkingEnabled;\n    /*if(this.isLinkingEnabled){\n      if(this.isLinkingBidirectional){\n        this.isLinkingBidirectional = false;\n      }else{\n        this.isLinkingEnabled = false;\n      }\n    }else{\n        this.isLinkingBidirectional = false;\n        this.isLinkingEnabled = true;\n    }*/\n  }\n\n  toggleUndirectedEdgeState() {\n    this.isLinkingBidirectional = !this.isLinkingBidirectional;\n    this.isLinkingEnabled = false;\n    /*if(this.isLinkingEnabled){\n      if(this.isLinkingBidirectional){\n        this.isLinkingEnabled = false;\n        this.isLinkingBidirectional = false;\n      }else{\n        this.isLinkingBidirectional = true;\n      }\n    }else{\n      this.isLinkingEnabled = true;\n      this.isLinkingBidirectional = true;\n    }*/\n  }\n\n  togglePan() {\n    // debugger;\n    this.isDragButtonEnabled = !this.isDragButtonEnabled;\n  }\n\n  getNodeTypeAsString(node: any): string {\n    if (this.isNode(node)) {\n      const nodeType: NodeType = node.nodeType;\n      switch (nodeType) {\n        case NodeType.Intermediate: {\n          return 'Intermediate';\n        }\n        case NodeType.Goal: {\n          return 'Goal';\n        }\n        case NodeType.Start: {\n          return 'Start';\n        }\n      }\n    } else {\n      return 'OOPs, something went wrong!';\n    }\n  }\n\n  isNode(node: any) {\n    if (node == null) {\n      return false;\n    }\n\n    return node.type === 'UIElementNode';\n  }\n\n  isStartNode(node: any): boolean {\n    if (!this.isNode(node)) {\n      throw new DOMException('The object is not UIElementNode type');\n    }\n    const nodeType: NodeType = node.nodeType;\n    return (nodeType === NodeType.Start);\n  }\n\n  isGoalNode(node: any ): boolean {\n    if (!this.isNode(node)) {\n      throw new DOMException('The object is not UIElementNode type');\n    }\n    const nodeType: NodeType = node.nodeType;\n    return (nodeType === NodeType.Goal);\n  }\n\n  isIntermediateNode(node: any): boolean {\n    if (!this.isNode(node)) {\n      throw new DOMException('The object is not UIElementNode type');\n    }\n    const nodeType: NodeType = node.nodeType;\n    return (nodeType === NodeType.Intermediate);\n  }\n\n  makeStartNode(node: any) {\n\n    if (this.isGoalNode(node)) {\n      delete this.nodes[node.id];\n    }\n\n    if (this.startNode != null) {\n      this.startNode.set({\n        fill : NodeColorMapper.GetIntermediateNodeColor(),\n        dirty : true,\n        nodeType : NodeType.Intermediate\n      });\n    }\n\n    this.activeObject.set({\n      fill : NodeColorMapper.GetStartNodeColor(),\n      dirty : true,\n      nodeType : NodeType.Start\n    });\n\n    this.startNode = this.activeObject;\n\n    this.canvas.requestRenderAll();\n  }\n\n  makeGoalNode(node: any) {\n    debugger;\n    if (this.goalNodes[node.id] !== undefined) {\n      return; // the node is already a goal node\n    }\n    this.goalNodes[node.id] = node;\n    node.set({\n      fill : NodeColorMapper.GetGoalNodeColor(),\n      dirty : true,\n      nodeType : NodeType.Goal\n    });\n    this.canvas.requestRenderAll();\n  }\n\n  makeIntermediateNode(node: any) {\n    if (this.isGoalNode(node)) {\n      node.set({\n        fill : NodeColorMapper.GetIntermediateNodeColor(),\n        dirty : true,\n        nodeType : NodeType.Intermediate\n      });\n      delete this.goalNodes[node.id];\n    }\n\n    if (this.startNode === node) {\n      this.startNode.set({\n        fill : NodeColorMapper.GetIntermediateNodeColor(),\n        dirty : true,\n        nodeType : NodeType.Intermediate\n      });\n      this.startNode = null;\n    }\n\n    this.canvas.requestRenderAll();\n\n  }\n\n  zoomIn() {\n    let zoom = this.canvas.getZoom();\n    this.zoom = Math.round(zoom * 5) / 5;\n    console.log('Zoom: ' + zoom);\n    zoom = zoom + 0.01;\n\n    if (zoom > 20) { zoom = 20; }\n    if (zoom < 0.01) { zoom = 0.01; }\n\n    // get the centre of the screen\n    const screenCenter: XY = this.getScreenCenter();\n    this.canvas.zoomToPoint({ x: screenCenter.X, y: screenCenter.Y }, zoom); // point, zoom amount\n  }\n\n  zoomOut() {\n    let zoom = this.canvas.getZoom();\n    this.zoom = Math.round(zoom * 5) / 5;\n    console.log('Zoom: ' + zoom);\n    zoom = zoom - 0.01;\n\n    if (zoom > 20) { zoom = 20; }\n    if (zoom < 0.01) { zoom = 0.01; }\n\n    // get the centre of the screen\n    const screenCenter: XY = this.getScreenCenter();\n    this.canvas.zoomToPoint({ x: screenCenter.X, y: screenCenter.Y }, zoom); // point, zoom amount\n  }\n\n  zoomOutBy(zoomAmount){\n    let zoom = this.canvas.getZoom();\n    this.zoom = Math.round(zoom * 5) / 5;\n    console.log('Zoom: ' + zoom);\n    zoom = zoom - zoomAmount;\n\n    if (zoom > 20) { zoom = 20; }\n    if (zoom < 0.01) { zoom = 0.01; }\n\n    // get the centre of the screen\n    const screenCenter: XY = this.getScreenCenter();\n    this.canvas.zoomToPoint({ x: screenCenter.X, y: screenCenter.Y }, zoom); // point, zoom amount\n  }\n\n  groupFocus() {\n    const nodeIds = this.objectKeys(this.nodes);\n    let node = this.nodes[nodeIds[0]];\n\n    const nodeRadius = node.radius;\n\n    let leftMost = node.left - nodeRadius;\n    let rightMost = node.left + nodeRadius;\n    let topMost = node.top - nodeRadius;\n    let bottomMost = node.top + nodeRadius;\n    let currentFileLeftMost, currentFileRightMost, currentFileBottomMost, currentFileTopMost;\n    // get the bounding left, right, top and bottom coordinates\n    nodeIds.forEach(nodeId => {\n      node = this.nodes[nodeId];\n      currentFileLeftMost = node.left - nodeRadius;\n      currentFileRightMost = node.left + nodeRadius;\n      currentFileBottomMost = node.top + nodeRadius;\n      currentFileTopMost = node.top - nodeRadius;\n\n      if (currentFileLeftMost < leftMost) {\n        leftMost = currentFileLeftMost;\n      }\n      if (currentFileRightMost > rightMost) {\n        rightMost = currentFileRightMost;\n      }\n\n      if (currentFileBottomMost > bottomMost) {\n        bottomMost = currentFileBottomMost;\n      }\n      if (currentFileTopMost < topMost) {\n        topMost = currentFileTopMost;\n      }\n    });\n\n    // find the zoom level such that the focus area will fit\n    const focusWidth = Math.abs(rightMost - leftMost);\n    const focusHeight = Math.abs(topMost - bottomMost);\n\n    const widthMargin = this.canvasElementWidth * 5 / 100;\n    const heightMargin = this.canvasElementHeight * 5 / 100;\n\n    const widthZoom = (this.canvasElementWidth - widthMargin) / focusWidth;\n    const heightZoom = (this.canvasElementHeight - heightMargin) / focusHeight;\n    let zoom;\n\n    const heightAfterWidthZoom = focusHeight * widthZoom;\n    const widthAfterHeightZoom = focusWidth * heightZoom;\n\n    let widthZoomBool = false;\n    let heightZoomBool = false;\n    let noZoom = false;\n\n    if (heightAfterWidthZoom <= this.canvasElementHeight) {\n      zoom = widthZoom;\n      widthZoomBool = true;\n    } else {\n      if (widthAfterHeightZoom <= this.canvasElementWidth) {\n        zoom = heightZoom;\n        heightZoomBool = true;\n      } else {\n        noZoom = true;\n      }\n    }\n    if (noZoom === true) {\n      return;\n    }\n\n    // set the focus area\n    this.canvas.setZoom(zoom);\n    this.canvas.requestRenderAll();\n\n    // translate the canvas so that the focus area is the center of the screen\n    const viewPortTra = this.canvas.viewportTransform;\n\n    // // object center is in world coordinates\n    const focusCenterX = leftMost + focusWidth / 2;\n    const focusCenterY = topMost + focusHeight / 2;\n\n    // screen center, represents the screen coordinates on the screen, i.e. the center of the screen\n    const screenCenterX = this.canvasElementWidth / 2;\n    const screenCenterY = this.canvasElementHeight / 2;\n\n    // represents the real world coordinates\n    const screenCenterAsWorldUnitsX = (screenCenterX - viewPortTra[4]) * (1 / zoom);\n    const screenCenterAsWorldUnitsY = (screenCenterY - viewPortTra[5]) * (1 / zoom);\n\n    // // diff in screen and object centers\n    const xDiff = (focusCenterX - screenCenterAsWorldUnitsX);\n    const yDiff = (focusCenterY - screenCenterAsWorldUnitsY);\n\n    const translationXasScreenCoordinates = xDiff * (zoom);\n    const translationYasScreenCoordinates = yDiff * (zoom);\n\n    // translate the canvas\n    this.canvas.viewportTransform[4] = viewPortTra[4] - translationXasScreenCoordinates;\n    this.canvas.viewportTransform[5] = viewPortTra[5] - translationYasScreenCoordinates;\n    this.canvas.requestRenderAll();\n  }\n\n  showHelp() {\n    this.dialog.open(HelpDialogComponent);\n  }\n\n  getDestinationNodesFor(currentNode: any): any[] {\n    const destinationNodes = [];\n    Object.keys(currentNode.asSource).forEach(edgeId => {\n      const edge = this.getEdge(edgeId);\n      destinationNodes.push(edge.destination);\n    });\n    return destinationNodes;\n  }\n\n  getSourceNodesFor(currentNode: any): any[] {\n    const sourceNodes = [];\n    Object.keys(currentNode.asDestination).forEach(edgeId => {\n      const edge = this.getEdge(edgeId);\n      sourceNodes.push(edge.source);\n    });\n    return sourceNodes;\n  }\n\n  getAllNeighbouringNodes(currentNode: any): any[] {\n    let sourceNodes = this.getSourceNodesFor(currentNode);\n    let destinationNodes = this.getDestinationNodesFor(currentNode);\n    let allNodes = []\n    \n    sourceNodes.forEach(element => {\n      allNodes.push(element);\n    });\n\n    destinationNodes.forEach(element => {\n      allNodes.push(element);\n    });\n\n    return allNodes;\n  }\n\n  getEdge(edgeId: string) {\n    return this.edges[edgeId];\n  }\n\n  distanceToNearestGoal(queryNode: any): number {\n    // iterate over all the goal nodes and return the distance that is closest to the queryNode\n    let closestDistance = Number.MAX_VALUE;\n    Object.keys(this.goalNodes).forEach(goalNodeId => {\n        const goalNode = this.goalNodes[goalNodeId];\n        const dist = goalNode.getDistanceTo(queryNode);\n        if (dist < closestDistance) {\n          closestDistance = dist;\n        }\n    });\n\n    return closestDistance;\n  }\n\n}\n\n@Component({\n  selector: 'app-help-dialog',\n  templateUrl: 'help-dialog.html'\n})\nexport class HelpDialogComponent {\n  constructor() {}\n}\n\n\n","// This file can be replaced during build by using the `fileReplacements` array.\n// `ng build --prod` replaces `environment.ts` with `environment.prod.ts`.\n// The list of file replacements can be found in `angular.json`.\n\nexport const environment = {\n  production: false\n};\n\n/*\n * For easier debugging in development mode, you can import the following file\n * to ignore zone related error stack frames such as `zone.run`, `zoneDelegate.invokeTask`.\n *\n * This import should be commented out in production mode because it will have a negative impact\n * on performance if an error is thrown.\n */\n// import 'zone.js/dist/zone-error';  // Included with Angular CLI.\n","import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n","/* (ignored) */","/* (ignored) */","/* (ignored) */"],"sourceRoot":""}